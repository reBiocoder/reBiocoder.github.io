{"meta":{"title":"Echor","subtitle":"~~~","description":"description","author":"Echor","url":"https://rebiocoder.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-01-04T13:01:18.513Z","updated":"2021-01-04T13:01:18.513Z","comments":false,"path":"/404.html","permalink":"https://rebiocoder.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-01-04T13:36:17.221Z","updated":"2021-01-04T13:36:17.221Z","comments":false,"path":"about/index.html","permalink":"https://rebiocoder.github.io/about/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-01-04T13:01:23.501Z","updated":"2021-01-04T13:01:23.501Z","comments":false,"path":"books/index.html","permalink":"https://rebiocoder.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-01-04T13:01:28.601Z","updated":"2021-01-04T13:01:28.601Z","comments":false,"path":"categories/index.html","permalink":"https://rebiocoder.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-01-04T12:57:48.911Z","updated":"2021-01-04T12:57:48.911Z","comments":false,"path":"repository/index.html","permalink":"https://rebiocoder.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-01-04T13:01:34.761Z","updated":"2021-01-04T13:01:34.761Z","comments":false,"path":"tags/index.html","permalink":"https://rebiocoder.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[Golang]基础知识","slug":"访问","date":"2021-01-05T05:20:00.000Z","updated":"2021-01-05T08:51:53.009Z","comments":true,"path":"2021/01/05/访问/","link":"","permalink":"https://rebiocoder.github.io/2021/01/05/%E8%AE%BF%E9%97%AE/","excerpt":"","text":"变量声明1.单个变量声明 var name string 这样声明一个变量，注意如果没有赋初始值，那么字符串初始值为空字符串“”，int为0，float为0.0，bool为false，指针类型为nil。 在go中，单引号和双引号有区别。在初始化变量时，如果右值带有小数点，那么建议带上类型float32。 2.多个变量一起声明，声明多个变量 12345var ( old_name string age int gender float32) 3.匿名变量的优点 不分配内存，不占用内存空间 不需要你为命名无用的变量名而纠结 多次声明不会有任何问题 整型在go中最好不要直接使用int给变量作为type，原因在于在32位机器上，int表示4个字节相当于int32，在64位机器上，int 表示8个字节，相当于int64。 二进制表示一个数：0b110八进制表示一个数： 0o14十六进制表示一个数：0xC fmt格式化代码： 123456789%b 格式化为二进制，%c unicode码值%d 十进制%o 八进制%x 十六进制%X 十六进制%U unicode格式%E 科学计数法%f 浮点数格式 浮点型浮点数类型的值一般由整数部分、小数点“.”和小数部分组成。 其中，整数部分和小数部分均由10进制表示法表示。不过还有另一种表示方法。那就是在其中加入指数部分。指数部分由“E”或“e”以及一个带正负号的10进制数组成。比如，3.7E-2表示浮点数0.037。又比如，3.7E+1表示浮点数37。 有一点需要注意，在Go语言里，浮点数的相关部分只能由10进制表示法表示，而不能由8进制表示法或16进制表示法表示。比如，03.7表示的一定是浮点数3.7。 float32 和 float64Go语言中提供了两种精度的浮点数 float32 和 float64。 float32，也即我们常说的单精度，存储占用4个字节，也即4*8=32位，其中1位用来符号，8位用来指数，剩下的23位表示尾数。 float64，也即我们熟悉的双精度，存储占用8个字节，也即8*8=64位，其中1位用来符号，11位用来指数，剩下的52位表示尾数。 浮点数类型的取值范围可以从很微小到很巨大。浮点数取值范围的极限值可以在 math 包中找到： 常量 math.MaxFloat32 表示 float32 能取到的最大数值，大约是 3.4e38； 常量 math.MaxFloat64 表示 float64 能取到的最大数值，大约是 1.8e308； float32 和 float64 能表示的最小值分别为 1.4e-45 和 4.9e-324。 注意浮点数表示精度的问题： float32的精度只能提供大约6个十进制数（表示后科学计数法后，小数点后6位）的精度 float64的精度能提供大约15个十进制数（表示后科学计数法后，小数点后15位）的精度 byte和runebyte用来表示一个ASCII码字符，rune占有四个字节，表示一个unicode字符。 单引号用来表示字符，如果你使用双引号，就意味着你要定义一个字符串，赋值时与前面声明的前面会不一致，这样在编译的时候就会出错。 byte 和 uint8 没有区别，rune 和 uint32 没有区别，那为什么还要多出一个 byte 和 rune 类型呢？ 理由很简单，因为uint8 和 uint32 ，直观上让人以为这是一个数值，但是实际上，它也可以表示一个字符，所以为了消除这种直观错觉，就诞生了 byte 和 rune 这两个别名类型。 字符串字符串一般用双引号表示””，但是字符串也可以用``反引号，在反引号中，会忽略转义字符。 数组与切片数组是一个由固定长度的特定元素类型组成的序列。 注意： [3]int 与[4]int是不同的数据类型 如果在声明数组时，不想声明容量大小，可以使用name := [...]int&#123;&#125;类型的方式来让go自动识别大小。 可以给自定义的数组类型重命名，使用type关键字： 12type arr [3]intvar name arr &#x3D; arr &#123;1,2,3&#125; 数组 与 切片 有相同点，它们都是可以容纳若干类型相同的元素的容器 也有不同点，数组的容器大小固定，而切片本身是引用类型，它更像是 Python 中的 list ，我们可以对它 append 进行元素的添加。 取切片值： 123456789101112131415m :&#x3D; make([]int, 2, 10) fmt.Println(m) fmt.Printf(&quot;\\n&quot;) myarr :&#x3D; []int&#123;&#125; fmt.Println(myarr) myarr &#x3D; append(myarr, 2) fmt.Println(myarr) myarr &#x3D; append(myarr, []int&#123;7, 8, 9&#125;...) &#x2F;&#x2F;解包切片 fmt.Println(myarr) myarr &#x3D; append([]int&#123;100&#125;, myarr...) &#x2F;&#x2F;在第一个位置插入 fmt.Println(myarr) fmt.Println(myarr[len(myarr)-1]) myarr &#x3D; append(myarr[0:len(arr)-1], append([]int&#123;520, 520&#125;, myarr[len(myarr)-1:]...)...) &#x2F;&#x2F;在最后一个元素之前插入元素 fmt.Println(myarr) 字典与布尔类型字典字典的下标读取可以返回两个值，使用第二个返回值都表示对应的 key 是否存在，若存在ok为true，若不存在，则ok为false 123456789101112131415161718192021&#x2F;&#x2F;********************************************var socres map[string]int &#x3D; map[string]int&#123;&quot;english&quot;: 92, &quot;chinese&quot;: 85&#125;fmt.Println(socres)users :&#x3D; make(map[string]int) &#x2F;&#x2F;初始化一个字典fmt.Println(users)users[&quot;Echor&quot;] &#x3D; 19 &#x2F;&#x2F;添加元素users[&quot;zhou&quot;] &#x3D; 20fmt.Println(users)users[&quot;zhou&quot;] &#x3D; 21 &#x2F;&#x2F;添加重复键元素fmt.Println(users)fmt.Println(users[&quot;zhou&quot;]) &#x2F;&#x2F;得到存在元素_, ok :&#x3D; users[&quot;sss&quot;]fmt.Println(ok) &#x2F;&#x2F;得到不存在元素delete(users, &quot;zhou&quot;) &#x2F;&#x2F;删除存在元素fmt.Println(users)delete(users, &quot;sss&quot;) &#x2F;&#x2F;删除不存在元素fmt.Println(users) fmt.Println(users)for k, v :&#x3D; range socres &#123; &#x2F;&#x2F;循环得到键值对 fmt.Println(k, v)&#125; 布尔类型关于布尔值，无非就两个值：true 和 false。只是这两个值，在不同的语言里可能不同。 而在 Go 中，真值用 true 表示，不但不与 1 相等，并且更加严格，不同类型无法进行比较，而假值用 false 表示，同样与 0 无法比较。 指针指针的概念学了c语言将不难理解，变量分为普通变量和指针变量； 流程控制if-else if- else 判断在golang中if-else if -else有以下特点： 在if之后可以接一个表达式 &#125;else&#123; &#125;else if&#123;必须和左右括号在同一行 switch-case注意： 在case后面可以接多个判断条件，他们的关系是”或“； 可以使用fallthrough进行穿透，但是只能穿透一层； 当条件都不匹配时，匹配default for循环for 循环的基本模型 1234for [condition | ( init; condition; increment ) | Range]&#123; statement(s);&#125; 注意： 在go中没有while，通过for&#123;&#125;（在for后面不加任何表达式来控制无线循环） for range遍历可以可迭代对象。for range的for后面不能添加任何表达式 goto不建议使用，使用方法如下： 12345goto flag: ****flag: **** **** defer语句 延迟调用。defer 的用法很简单，只要在后面跟一个函数的调用，就能实现将这个 xxx 函数的调用延迟到当前函数执行完后再执行。 多个defer满足”先进后出“的条件","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://rebiocoder.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://rebiocoder.github.io/tags/Golang/"}],"author":"Echor"},{"title":"tornado后端session用户认证鉴权解决方案","slug":"tornado后端session用户认证鉴权解决方案","date":"2021-01-05T02:39:00.000Z","updated":"2021-01-05T02:41:37.713Z","comments":true,"path":"2021/01/05/tornado后端session用户认证鉴权解决方案/","link":"","permalink":"https://rebiocoder.github.io/2021/01/05/tornado%E5%90%8E%E7%AB%AFsession%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E9%89%B4%E6%9D%83%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"tornado框架自身没有集成session鉴权，但是对cookie支持良好。由于现在前端vue部署在一个端口上，后端tornado分布式应用部署在多个端口上，这就会导致浏览器的跨域问题产生（url不同，即协议，域名，端口三者有不相同的地方）。 在前后端分离的项目中，由于页面的路由跳转由vue控制，后端应用只提供数据。这样就会使鉴权任务变得较为复杂。一个比较良好的解决思路是，在前端需要鉴权才能访问的路由中添加一个后端异步请求，该请求用来判断用户是否登录，这样来判断用户当前是否有权限访问该页面。同时，后端需要 登录才能访问的接口，用修饰器来判断用户当前是否登录。下面提供一种tornado实现session的解决方案。在新建一个HTTP请求时，需要初始化一个session类，该类应该实现以下功能： 能够从请求头的cookie中得到session_id； 能够生成一个全新的session_id，并将其返回给client； 若server得到的session_id失效，则清空client的cookie； 若server得到的sess_id有效，则从redis中取出对应的用户信息 在一个HTTP请求结束时，需要判断，当前这个链接是否为”登录成功“的API，如果是，则需要将对应的用户信息存储到redis中，并生成一个新的session_id返回给用户。 代码如下：BaseHandler 1234567891011121314151617181920212223242526272829303132class BaseHandler(web.RequestHandler): def initialize(self): self.session_save_tag &#x3D; False self.session &#x3D; None async def prepare(self): await self.init_session() if get_config().session[&#39;session_key_name&#39;] in self.session: self.current_user &#x3D; LoginUser(self.session[get_config().session[&#39;session_key_name&#39;]]) def on_finish(self): if self.session is not None and self.session_save_tag: get_loop().add_callback(self.session.save) get_logger().info(&quot;[一次HTTP请求结束]&quot;) async def init_session(self): if not self.session: self.session &#x3D; Session(self) await self.session.init_fetch() def save_session(self): self.session_save_tag &#x3D; True self.session.generate_session_id() get_logger().info(&quot;【登录】生成session_id结束&quot;) def save_login_user(self, user: dict): login_user &#x3D; LoginUser(None) login_user[&#39;username&#39;] &#x3D; user.get(&quot;username&quot;, &quot;&quot;) login_user[&#39;email&#39;] &#x3D; user.get(&quot;email&quot;, &quot;&quot;) login_user[&#39;phone&#39;] &#x3D; user.get(&quot;phone&quot;, &quot;&quot;) self.session[get_config().session[&#39;session_key_name&#39;]] &#x3D; login_user self.current_user &#x3D; login_user self.save_session() login API 123456789101112131415class LoginHandler(BaseHandler): async def post(self): try: username &#x3D; self.data[&#39;username&#39;] password &#x3D; self.data[&#39;password&#39;] doc_user &#x3D; await get_one_data(self.mongodb_manager, Config.mongodb_config[&#39;user_info&#39;], &#123;&#39;username&#39;: username&#125;) print(doc_user) if doc_user is not None and password &#x3D;&#x3D; doc_user[&#39;password&#39;]: self.save_login_user(doc_user) get_logger().info(&quot;登录成功,用户信息已经保存&quot;) except Exception as e: error &#x3D; traceback.format_exc() get_logger().error(&quot;login fail[&#123;&#125;]:&#123;&#125;&quot;.format(e, error))","categories":[{"name":"架构设计","slug":"架构设计","permalink":"https://rebiocoder.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"tornado","slug":"tornado","permalink":"https://rebiocoder.github.io/tags/tornado/"}],"author":"Echor"},{"title":"微服务设计阅读学习","slug":"微服务设计阅读学习","date":"2021-01-04T14:09:00.000Z","updated":"2021-01-04T14:11:26.166Z","comments":true,"path":"2021/01/04/微服务设计阅读学习/","link":"","permalink":"https://rebiocoder.github.io/2021/01/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"微服务的概念网上都有，各种博客都有解释。但是自己没有上手写代码，没有做工程项目，实际上是很难体会的。 微服务与SOA（面向服务的架构）的区别主要在于微服务中每个服务是一个独立的进程，它能够被独立的部署。若该服务宕机，并不影响整个系统中其他服务的正常运行。 在开始尝试做一个新的系统时，若常用微服务的方式，则需要使用限界上下文划分微服务边界。限界上下文指的是一个由显式边界限定的特定职责。如果你想要从一个限界上下文中获取信息，或者向其发起请求，需要使用模型和它的显式边界进行通信。实际上寻找限界上下文边界就是将整个业务逻辑进行一个粗粒度的划分。对于一个新系统而言，过早划分很容易错误判断服务之间的边界，按照书中内容所说，很多时候，将一个已有的代码库划分成微服务，要比从头开始构建微服务简单得多。 当你在思考组织内的限界上下文时，不应该从共享数据的角度来考虑，而应该从这些上下文能够提供的功能来考虑。服务与服务之间如果能够做到低耦合，高内聚，那么这就是一个好的微服务系统。实际上，要做到低耦合，高内聚还是很困难的，在工程项目中很可能遇到一份代码需要多次拷贝使用，当遇到这种情况时，就需要注意DRY（don’t repeat yourself）。应该考虑使用更好的设计模式来避免这种情况，因为很容易出现，一个地方被修改了，但是另一个地方忘记修改的情况。 服务集成是微服务相关技术中最重要的一个问题，按照作者的话来说：做得好的话，你的微服务可以保持自治性，你也可以独立地修改和发布它们；但做得不好的话会带来灾难。在选择集成方式时，需要注意以下几个原则：1.避免破坏性修改 2. 保证API的技术无关系3.使你的服务易于消费方使用4.隐藏内部实现细节。服务之间的通信可以分为同步和异步两种：如果使用同步通信，发起一个远程服务调用后，调用方会阻塞自己并等待整个操作的完成。如果使用异步通信，调用方不需要等待操作完成就可以返回，甚至可能不需要关心这个操作完成与否。这两种不同的通信模式有着各自的协作风格，即请求/响应或者基于事件。对于请求/响应来说，客户端发起一个请求，然后等待响应。这种模式能够与同步通信模式很好地匹配，但异步通信也可以使用这种模式。我可以发起一个请求，然后注册一个回调，当服务端操作结束之后，会调用该回调。对于使用基于事件的协作方式来说，情况会颠倒过来。客户端不是发起请求，而是发布一个事件，然后期待其他的协作者接收到该消息，并且知道该怎么做。 服务与服务之间常见有两种常见的架构风格：编排与协同。 对于上图用户注册这样一个业务逻辑，如果用编排的风格来设计服务，我们可以得到如下的架构图： 很显然，若编排的架构使用的是同步通信的机制，即请求/响应的协作方式，那么我们能够得到每一个服务返回的结果。当然，编排的架构也能使用基于回调的异步通信。编排架构的缺点在于，客户服务承担了太多的职责，而剩下的三个服务按作者的话来说：会成为贫血的CRUD服务。 如果采用协同的架构风格，我们可以得到下面这个架构图： 可以仅仅从客户服务中使用异步的方式触发一个事件，该事件名可以叫作“客户创建”。电子邮件服务、邮政服务及积分账户可以简单地订阅这些事件并且做相应处理，如上图所示，这种方法能够显著地消除耦合。使用协同的方式组织服务，很显然必定是异步的。使用这种发布-订阅的模式，是当前非常流行的一种通信模式，典型的就是消息队列，比如RabbitMQ。这种模式能够很大程度的在服务之间进行解耦，但是它的一个问题在于无法检测服务是否成功执行，比如电子邮件服务出现问题，无法发送邮件，此时整个系统是否能够检测到该问题，并进行处理。一个常见的解决方案是构建一个与业务逻辑流程图相匹配的监控系统。实际的监控活动是针对每个服务的，但最终需要把监控的结果映射到业务流程中。针对请求响应的协同方式，常用有两种技术：RPC和REST（表征性状态转移）风格的HTTP。针对基于事件的协同方式，一般采用消息队列来实现。 微服务的部署相对于单体应用来说，也是一个较为复杂的问题。CI/CD（持续集成/持续部署）是当前非常重要的一种思想。按照书中所说，判断你的项目是否CI，可以通过回答一下几个问题来判断：1.你是否每天签入代码到主线？2.你是否有一组测试来验证修改？3.当构建失败后，团队是否把修复CI当作第一优先级的事情来做？我个人感觉CI/CD应该是用来解决开发和运维之间的矛盾，应该需要一个DevOps系统来实现这种思想。","categories":[{"name":"架构设计","slug":"架构设计","permalink":"https://rebiocoder.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"}],"tags":[],"author":"Echor"},{"title":"unix环境高级编程：高级I/O理解","slug":"unix环境高级编程：高级I-O理解","date":"2021-01-04T13:58:00.000Z","updated":"2021-01-04T14:02:25.397Z","comments":true,"path":"2021/01/04/unix环境高级编程：高级I-O理解/","link":"","permalink":"https://rebiocoder.github.io/2021/01/04/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%9A%E9%AB%98%E7%BA%A7I-O%E7%90%86%E8%A7%A3/","excerpt":"","text":"在网络通信中，数据的传输大部分基于socket（socket位于TCP/UDP与HTTP协议之间，当然socket也可以利用SOCK_RAW套接字提供一个数据报接口，用于直接访问下面的网络层，当使用SOCKT_RAW套接字时，应用程序应该构造自己的协议头部）。在unix系统中，将socket的操作抽象为文件的读，写，异常，即一个socket对象可以对应为一个文件描述符(fd)。所以网络I/O与磁盘读写O/I可以属于同一层次上要考虑的问题。 在考虑具体问题之前，首先要明确一个概念，阻塞与非阻塞是对于进程而言：当一个进程想要read一个文件描述符(fd)时，若fd的读缓冲区没有数据，此时进程将会阻塞，直到缓冲区中有数据可以使用，此时进程才会继续向下运行，这种情况便是阻塞I/O。对非阻塞I/O而言，当fd的读缓冲区中没有数据时，进程并不会阻塞在此处，而是立即返回错误，表示该操作如继续执行将会阻塞。下图是一个非阻塞I/O的例子(a.out) 执行以下代码： ./a.out &lt; /etc/services 2&gt;stderr.out 可以得到如下结果： 其中35对应的是EAGAIN信号，显然一次输出到终端的数据是有限的，当数据不能write到终端时，进程并没有阻塞，而是返回信号EAGAIN,表明当前写缓冲区已满， 以上代码便是一种轮询操作。 考虑如下一种场景：当该进程必须要从两个或多个fd中同时读取数据时，在这种情况下，我们不能将进程阻塞在任何一个fd的read方法上，原因是，另一个fd可能已经准备好read了，但进程阻塞，无法对其进行任何操作。为了能够使进程同时处理多个fd，我们的第一个想是fork子进程，或者用多线程同时阻塞处理。但这在实现上较为繁琐，且占用资源。另外，也可以用轮询的方法来遍历fd的状态。第三种方法是用异步I/O：进程告诉内核，当fd准备好可以进行I/O时，用一个信号通知进程，这种方法存在的问题在于：每个进程只能有一个信号，如果信号对多个fd都起作用，那么进程在收到该信号时，无法判断是哪个fd准备就绪。以上三种方法或多或少都有问题，我们主要考虑I/O多路转接技术。I/O多路转接技术想要实现的作用是：将想监听的fd加入一个列表，用某个函数来监听这个列表，当列表中有fd准备就绪时，返回准备就绪的fd给进程使用。select函数和poll函数便是实现该功能。select函数如下： 传给select的参数告诉内核： 我们所关心的描述符 对于每个描述符，我们所关心的条件 愿意等待多长时间 select将会返回： 已经准备好的描述符的总数量 对于读，写，异常，哪些描述符已经准备好了。 该函数返回的fd一定是准备就绪的，调用对应的read,write函数一定不会发生阻塞。select函数的具体实现过程： 12345678910111. 从用户态copy fd_set到内核空间2. 注册回调函数pollwait（将进程挂到每个socket的等待队列中，当socket准备好后（执行mask状态码进行判断，再唤醒进程））3. 内核遍历fd，调用每一个fd的poll方法，返回socket的mask状态掩码，即现在准备好了没有，给fd_set赋值4.当无可读写mask码时，select睡眠（On Linux, select() modifies timeout to reflect the amount of time not slept），等睡眠时间到，再次醒来轮询fd_set（内核态轮询）5. 有值时返回fd_set，将其copy到用户空间6. 用户进程变为运行态，循环fd_set，得到准备好的fd。 内核创建一个epoll对象，epoll_ctl函数向epoll对象中添加需要监听的fd，当fd准备就绪时，中断程序会操作epoll对象，而不是操作进程。当进程执行到epoll_wait时，如果就绪列表存在已经准备好的fd，进程将会被唤醒。 epoll的作用是提升事件循环查询“io事件”的效率，他允许用户进程同时监听多个文件描述符的io事件即io多路复用。同时epoll在实现上是十分高效的，相对于poll/select，epoll使得进程可以监控更多的文件描述符。epoll采用注册机制，在内核中保存用户关注的文件描述符（红黑树保存），不像select一样每次都需要传入所有的文件描述符，效率更高(减少了从用户空间向内核空间的拷贝)。epoll不像select一样会在内核中轮询所有的文件描述符（低效的），epoll会在不同文件描述符对应的设备的等待队列中添加一个回调函数，在回掉函数中将对应的文件描述符添加至epoll的rdlist队列（高效的），当进程调用epoll_wait时，内核检查该队列是否为空，如果是空则阻塞进程，如果不为空则将该队列拷贝至用户空间，并返回该函数。epoll的两种触发模式： 1.水平触发：只要fd仍然可读或写，每次调用epoll_wait都会返回该文件描述符； 2.边缘触发：只fd仍然可读或写，每次调用epoll_wait只会返回一次该文件描述符； 注意异步I/O与非阻塞I/O的区别，异步I/O，需要用回调函数来处理，fd准备好之后的情况，比较复杂。而非阻塞则是在fd的read，write操作时，一定可以立即得到结果，不会阻塞进程。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://rebiocoder.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"unix","slug":"unix","permalink":"https://rebiocoder.github.io/tags/unix/"}],"author":"Echor"},{"title":"机器学习（1）","slug":"学习（1）","date":"2020-06-01T02:27:00.000Z","updated":"2021-01-05T04:10:18.129Z","comments":true,"path":"2020/06/01/学习（1）/","link":"","permalink":"https://rebiocoder.github.io/2020/06/01/%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/","excerpt":"","text":"1.监督学习 回归： 预测连续值 分类：预测离散值 2.无监督学习 聚类算法 鸡尾酒算法 梯度下降![QOLJD78`A_BYQ_DIY_DGNWG.png](https://i.loli.net/2020/06/01/ugZyM5nDhRqdTUX.png) 正确更新方式是同时更新x1和x2 计算偏导数 logistics 函数![C_CNR7D`BWNRDQI27~R_AZF.png](https://i.loli.net/2020/06/01/KG52sOlePuikzRM.png) logistics代价函数","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://rebiocoder.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://rebiocoder.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"author":"我爱小徐子"},{"title":"二叉树中序遍历（栈）","slug":"树中序遍历","date":"2020-04-22T08:09:00.000Z","updated":"2021-01-05T04:10:18.325Z","comments":true,"path":"2020/04/22/树中序遍历/","link":"","permalink":"https://rebiocoder.github.io/2020/04/22/%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"leetcode94问题：栈的方式实现二叉树 12345678910111213class Solution: def middelTravel(self, r): stack, ret &#x3D; [], [] root &#x3D; r while stack or root: if root: stack.append(root) root &#x3D; root.left else: s &#x3D; stack.pop() ret.append(s.val) root &#x3D; s.right return ret 关键点：1.根节点先入栈，然后以左节点为根节点，直到左节点为空，将根节点出栈。 以右节点为根节点","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"我爱小徐子"},{"title":"二叉树子树","slug":"叉树子树","date":"2020-04-22T07:36:00.000Z","updated":"2021-01-05T04:10:18.177Z","comments":true,"path":"2020/04/22/叉树子树/","link":"","permalink":"https://rebiocoder.github.io/2020/04/22/%E5%8F%89%E6%A0%91%E5%AD%90%E6%A0%91/","excerpt":"","text":"leetcode572问题：判断t是否为s的子树 1234567891011python解决方案class TreeNode: def __init__(self): self.val &#x3D; val self.left &#x3D; None self.right &#x3D; Noneclass Solution: def isSubtitle(t,s): def up(t): return (t.val, up(t.left), up(t.right)) if t else None return str(up(t)) in str(up(s)) 注意点： 元组中的元素位置不会发生变化 print(“a” in “ab”) 返回true","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"我爱小徐子"},{"title":"二叉树右视图","slug":"叉树右视图","date":"2020-04-22T06:33:00.000Z","updated":"2021-01-05T04:10:18.277Z","comments":true,"path":"2020/04/22/叉树右视图/","link":"","permalink":"https://rebiocoder.github.io/2020/04/22/%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE/","excerpt":"","text":"二叉树右视图（leetcode 199） 12345678910111213141516class TreeNode: def __init__(self,x): self.val &#x3D; x self.left &#x3D; None self.right &#x3D; Noneclass Solution: def rightDideView(self, root: TreeNode) -&gt; List[int]: d &#x3D; &#123;&#125; def f(r,i): if r: d[i] &#x3D; r.val f(r.left, i+1) f(r.right, i+1) f(root,0) return [*d.values()] 思路： 1先序遍历，注意rightSideView(r-&gt;left, i+1)与rightSideView(r-right, i+1)中的i相同，由此可以知道，字典中存储的数据一定是每层的最后一个数据","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"我爱小徐子"},{"title":"UML类图","slug":"ML类图","date":"2020-04-16T03:39:18.000Z","updated":"2021-01-05T04:10:17.769Z","comments":true,"path":"2020/04/16/ML类图/","link":"","permalink":"https://rebiocoder.github.io/2020/04/16/ML%E7%B1%BB%E5%9B%BE/","excerpt":"","text":"类图基本属性123+表示public-表示private#表示protected 类与类的基本关系 12345678910111213141.依赖关系定义：有两个元素x和y，如果修改x的定义可能会引起对y的定义的修改，则称y依赖与元素x，用带箭头的虚线表示依赖关系，箭头指向被依赖的对象。2.泛化关系泛化关系就是子类与父类之间的继承关系。用带空心箭头的实线表示，箭头指向父类3.关联关系关联关系可以理解为ER图中的实体关系，用实现表示，上方标识数字来进行确认。4.聚合关系聚合关系是一种特殊的关联关系，聚合关系表示的是类之间整体与部分的关系，用带有空心菱形的实线表示，空心菱形指向代表整体的类。5.实现关系定义接口，用户带空心箭头的虚线来表示","categories":[],"tags":[],"author":"我爱小徐子"},{"title":"python导包时的一些细节问题","slug":"ython一些细节","date":"2020-03-22T02:21:00.000Z","updated":"2021-01-05T04:10:17.929Z","comments":true,"path":"2020/03/22/ython一些细节/","link":"","permalink":"https://rebiocoder.github.io/2020/03/22/ython%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/","excerpt":"","text":"python导包时的问题 1.可以使用sys.path,查看python导包的搜素路径;使用sys.modules来查看已经导入内存的模块. 一个细节点: import 模块 import只能导入模块(.py, .pyc,pyd),不能导入模块中的类和函数。如果需要导入模块中的函数或者对象，使用from 模块 import 对象 即为 1说一个容易忽略的问题，import只能导入模块，不能导入模块中的对象（类、函数、变量等）。如一个模块A（A.py）中有个函数getName，另一个模块不能通过import A.getName将getName导入到本模块，只能用import A。如果想只导入特定的类、函数、变量则用from A import getName即可。 2.嵌套导包 （1）在A.py中导入import B, 在B.py中导入了import C,则在A中只能使用B而不能使用C,即时C已经存在于内存之中。也就是说必须显示导包 （2）第二种情况 123456789[A.py] from B import Cclass D:pass[B.py]from A import Dclass C:pass 在A中执行C()时,将会报错, 而如果改成import B则可以导入,解释如下: 123456789101112131415161718192021222324252627282930313233另外一种嵌套指，在模块A中import B，而在模块B中import A。这时会怎么样呢？这个在Python列表中由RobertChen给出了详细解释，抄录如下：[A.py] from B import D class C:pass [B.py] from A import C class D:pass为什么执行A的时候不能加载D呢？如果将A.py改为：import B就可以了。这是怎么回事呢？RobertChen：这跟Python内部import的机制是有关的，具体到from B import D，Python内部会分成几个步骤：在sys.modules中查找符号&quot;B&quot;果符号B存在，则获得符号B对应的module对象。从的__dict__中获得符号&quot;D&quot;对应的对象，如果&quot;D&quot;不存在，则抛出异常如果符号B不存在，则创建一个新的module对象，注意，这时，module对象的__dict__为空。执行B.py中的表达式，填充的__dict__ 。从的__dict__中获得&quot;D&quot;对应的对象，如果&quot;D&quot;不存在，则抛出异常。所以，这个例子的执行顺序如下：1、执行A.py中的from B import D由于是执行的python A.py，所以在sys.modules中并没有存在，首先为B.py创建一个module对象()，注意，这时创建的这个module对象是空的，里边啥也没有，在Python内部创建了这个module对象之后，就会解析执行B.py，其目的是填充这个dict。2、执行B.py中的from A import C在执行B.py的过程中，会碰到这一句，首先检查sys.modules这个module缓存中是否已经存在了，由于这时缓存还没有缓存，所以类似的，Python内部会为A.py创建一个module对象()，然后，同样地，执行A.py中的语句。3、再次执行A.py中的from B import D这时，由于在第1步时，创建的对象已经缓存在了sys.modules中，所以直接就得到了，但是，注意，从整个过程来看，我们知道，这时还是一个空的对象，里面啥也没有，所以从这个module中获得符号&quot;D&quot;的操作就会抛出异常。如果这里只是import B，由于&quot;B&quot;这个符号在sys.modules中已经存在，所以是不会抛出异常的。 导入包: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Package（包） Import包（Package）可以看成模块的集合，只要一个文件夹下面有个__init__.py文件，那么这个文件夹就可以看做是一个包。包下面的文件夹还可以成为包（子包）。更进一步，多个较小的包可以聚合成一个较大的包，通过包这种结构，方便了类的管理和维护，也方便了用户的使用。比如SQLAlchemy等都是以包的形式发布给用户的。包和模块其实是很类似的东西，如果查看包的类型import SQLAlchemy type(SQLAlchemy)，可以看到其实也是。import包的时候查找的路径也是sys.path。包导入的过程和模块的基本一致，只是导入包的时候会执行此包目录下的__init__.py而不是模块里面的语句了。另外，如果只是单纯的导入包，而包的__init__.py中又没有明确的其他初始化操作，那么此包下面的模块是不会自动导入的。如：PA--__init__.py--wave.py--PB1??--__init__.py??--pb1_m.py--PB2??--__init__.py??--pb2_m.py__init__.py都为空，如果有以下程序：?import?sysimport?PA.wave??#1import?PA.PB1???#2import?PA.PB1.pb1_m?as?m1??#3import?PA.PB2.pb2_m?#4PA.wave.getName()?#5m1.getName()?#6PA.PB2.pb2_m.getName()?#7当执行#1后，sys.modules会同时存在PA、PA.wave两个模块，此时可以调用PA.wave的任何类或函数了。但不能调用PA.PB1(2)下的任何模块。当前Local中有了PA名字。当执行#2后，只是将PA.PB1载入内存，sys.modules中会有PA、PA.wave、PA.PB1三个模块，但是PA.PB1下的任何模块都没有自动载入内存，此时如果直接执行PA.PB1.pb1_m.getName()则会出错，因为PA.PB1中并没有pb1_m。当前Local中还是只有PA名字，并没有PA.PB1名字。当执行#3后，会将PA.PB1下的pb1_m载入内存，sys.modules中会有PA、PA.wave、PA.PB1、PA.PB1.pb1_m四个模块，此时可以执行PA.PB1.pb1_m.getName()了。由于使用了as，当前Local中除了PA名字，另外添加了m1作为 PA.PB1.pb1_m的别名。当执行#4后，会将PA.PB2、PA.PB2.pb2_m载入内存，sys.modules中会有PA、PA.wave、PA.PB1、PA.PB1.pb1_m、PA.PB2、PA.PB2.pb2_m六个模块。当前Local中还是只有PA、m1。下面的#5，#6，#7都是可以正确运行的。注意的是：如果PA.PB2.pb2_m想导入PA.PB1.pb1_m、PA.wave是可以直接成功的。最好是采用明确的导入路径，对于.&#x2F;..相对导入路径还是不推荐用。","categories":[{"name":"python","slug":"python","permalink":"https://rebiocoder.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://rebiocoder.github.io/tags/python/"}],"author":"我爱小徐子"},{"title":"[算法设计]动态规划求最长公共子序列","slug":"法设计-动态规划求最长公共子序列","date":"2020-03-05T05:01:00.000Z","updated":"2021-01-05T04:17:24.829Z","comments":true,"path":"2020/03/05/法设计-动态规划求最长公共子序列/","link":"","permalink":"https://rebiocoder.github.io/2020/03/05/%E6%B3%95%E8%AE%BE%E8%AE%A1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B1%82%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"问题: 已知序列str1和序列str2,求出他们的最长公共子序列。 dp[i][j]的定义: str[0-i]和str[0-j]所拥有的最长公共子序列。 法一: 1234567891011121314def length_common_strength(str1, str2) -&gt; int: &quot;&quot;&quot; 递归法求解 :param str1: :param str2: :return: &quot;&quot;&quot; def dp(i, j): if i &#x3D;&#x3D; -1 or j &#x3D;&#x3D; -1: return 0 if str1[i] &#x3D;&#x3D; str2[j]: return dp(i-1, j-1) + 1 else: return max(dp(i-1, j), dp(i, j-1)) return dp(len(str1) - 1, len(str2) - 1) 法二: 12345678910111213141516def length_common_strength_dp(str1, str2) -&gt; int: &quot;&quot;&quot; dp背包 :param str1: :param str2: :return: &quot;&quot;&quot; m, n &#x3D; len(str1), len(str2) dp &#x3D; [[0] * (n + 1) for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): if str1[i-1] &#x3D;&#x3D; str2[j-1]: dp[i][j] &#x3D; dp[i-1][j-1] + 1 else: dp[i][j] &#x3D; max(dp[i-1][j], dp[i][j-1]) return dp[m][n]","categories":[{"name":"算法设计","slug":"算法设计","permalink":"https://rebiocoder.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"我爱小徐子"},{"title":"[算法设计]求最长子序列问题","slug":"法设计-求最长子序列问题","date":"2020-03-02T10:00:00.000Z","updated":"2021-01-05T04:17:07.237Z","comments":true,"path":"2020/03/02/法设计-求最长子序列问题/","link":"","permalink":"https://rebiocoder.github.io/2020/03/02/%E6%B3%95%E8%AE%BE%E8%AE%A1-%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题: 求无序序列的最长子序列 方法: 动态规划法 关键点: 1dp[i] : 表示数组中的第i位置的最长子序列的长度,初始默认所有位置的dp[i] &#x3D; 1 思路: 假设已知Subsequence[i-1]位置的最长子序列为dp[i-1],则dp[i],显然如果subsequence[i]&gt;subsequence[i-1],则dp[i] = dp[i-1] + 1 代码: 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;&#x2F;*求最长子序列*&#x2F;int main() &#123; const int MaxN &#x3D; 100; int Subsequence[MaxN]; int dp[MaxN]; for (int j &#x3D; 0; j &lt; MaxN; ++j) &#123; dp[j] &#x3D; 1; &#125; int n; scanf_s(&quot;%d&quot;, &amp;n); if (n !&#x3D; 0) &#123; for (int i &#x3D; 0; i &lt; n; ++i) &#123; scanf_s(&quot;%d&quot;, &amp;Subsequence[i]); &#x2F;&#x2F;子序 &#125; for (int i &#x3D; 0; i &lt; n; ++i) &#123; for (int j &#x3D; 0; j &lt; i; ++j) &#123; if (Subsequence[i] &gt; Subsequence[j]) &#123; dp[i] &#x3D; max(dp[j] + 1, dp[i]); &#125; &#125; &#125; printf(&quot;输入结束!\\n&quot;); for (int j &#x3D; 0; j &lt; n; ++j) &#123; printf(&quot;%d&quot;, Subsequence[j]); &#125; printf(&quot;\\n&quot;); for (int j &#x3D; 0; j &lt; n; ++j) &#123; printf(&quot;%d&quot;, dp[j]); &#125; &#125; return 0;&#125;","categories":[{"name":"算法设计","slug":"算法设计","permalink":"https://rebiocoder.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"我爱小徐子"},{"title":"[算法设计]斐波拉契优化与区间不相交问题","slug":"法设计与分析-5","date":"2020-03-02T03:11:00.000Z","updated":"2021-01-05T04:10:18.529Z","comments":true,"path":"2020/03/02/法设计与分析-5/","link":"","permalink":"https://rebiocoder.github.io/2020/03/02/%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-5/","excerpt":"","text":"斐波拉契数,最基本的定义用递归,现利用”自底向上”的思路求解: 1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;ctime&gt;int BaseFib(int n) &#123;&#x2F;&#x2F;暴力递归斐波拉契数列 if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) return 1; &#x2F;&#x2F;递归出口 return BaseFib(n - 1) + BaseFib(n - 2);&#125;int DpTableFib(int n) &#123;&#x2F;&#x2F;dpTable,自底向上 int dp[1000] &#x3D; &#123;0&#125;; &#x2F;&#x2F;初始化为0 dp[1] &#x3D; 1; dp[2] &#x3D; 1; for (int i &#x3D; 3; i &lt;&#x3D; n; ++i) &#123; dp[i] &#x3D; dp[i - 1] + dp[i - 2]; &#125; return dp[n];&#125;int main() &#123; int n &#x3D; 20; int m &#x3D; n; printf(&quot;%d&quot;, BaseFib(n)); printf(&quot;%d&quot;, DpTableFib(m)); return 0;&#125; 不相交子区间问题 123456789101112131415161718192021222324252627282930313233343536&#x2F;*区间不相交问题*&#x2F;#include &lt;algorithm&gt;using namespace std;const int MaxN &#x3D; 10;struct interval&#123; int x, y; &#x2F;&#x2F;开区间左右端点&#125; I[MaxN];bool cmp(interval a, interval b) &#123; if (a.x !&#x3D; b.x) return a.x &gt; b.x; &#x2F;&#x2F;先按照左端点从大到小的顺序排序 return a.y &lt; b.y; &#x2F;&#x2F; 如果左端点相同, 则按照右端点从小到大的顺序排序&#125;int main() &#123; int n; while (scanf_s(&quot;%d&quot;, &amp;n), n!&#x3D;0)&#123; for (int i &#x3D; 0; i &lt; n; ++i) &#123; scanf_s(&quot;%d%d&quot;, &amp;I[i].x, &amp;I[i].y); &#125; sort(I, I + n, cmp); int ans &#x3D; 1, lastX &#x3D; I[0].x; for (int i &#x3D; 1; i &lt; n; ++i) &#123; if (I[i].y &lt;&#x3D; lastX) &#123; lastX &#x3D; I[i].x; ans++; &#125; &#125; printf(&quot;%d&quot;,ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"我爱小徐子"},{"title":"[算法设计]全排列与n皇后问题","slug":"法设计与分析-4","date":"2020-02-28T10:37:00.000Z","updated":"2021-01-05T04:16:48.341Z","comments":true,"path":"2020/02/28/法设计与分析-4/","link":"","permalink":"https://rebiocoder.github.io/2020/02/28/%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-4/","excerpt":"","text":"全排列 递归算法求全排 1234567891011121314151617181920212223242526272829&#x2F;*递归求全排*&#x2F;const int MaxN &#x3D; 10;const int MAXSIZE &#x3D; 1000;int P[MaxN];bool hashTable[MAXSIZE] &#x3D; &#123; false &#125;; &#x2F;&#x2F;空间换取时间int n;void generateP(int index) &#123; if (index &#x3D;&#x3D; n + 1) &#123; for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123; printf(&quot;%d&quot;, P[i]); &#125; printf(&quot;\\n&quot;); return; &#125; for (int j &#x3D; 1; j &lt;&#x3D; n; ++j) &#123; if (hashTable[j] &#x3D;&#x3D; false) &#123; P[index] &#x3D; j; hashTable[j] &#x3D; true; generateP(index + 1); hashTable[j] &#x3D; false; &#125; &#125;&#125;int main() &#123; n &#x3D; 5; generateP(1);&#125; n皇后问题 12345678910111213141516171819202122232425262728293031323334&#x2F;&#x2F;n皇后问题,回溯法int count &#x3D; 0;void queen(int index) &#123;&#x2F;&#x2F;第n列的皇后 if (index &#x3D;&#x3D; n + 1) &#123;&#x2F;&#x2F;此时每一列都有一个皇后 count++; printf(&quot;%d\\n&quot;,count); return; &#125; for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123; if (hashTable[i] &#x3D;&#x3D; false) &#123;&#x2F;&#x2F;没有被使用过 bool flag &#x3D; true; &#x2F;&#x2F;表示当前序列与之前的皇后不冲突 for (int pre &#x3D; 1; pre &lt;&#x3D; index; ++pre) &#123;&#x2F;&#x2F;回溯剪枝 &#x2F;&#x2F;不能在同一对角线上 if (abs(pre - index) &#x3D;&#x3D; abs(i - P[pre])) &#123; flag &#x3D; false; break; &#125; &#125; if (flag) &#123; P[index] &#x3D; i; hashTable[i] &#x3D; true; queen(index + 1); hashTable[i] &#x3D; false; &#125; &#125; &#125;&#125;int main() &#123; n &#x3D; 8; queen(1);&#125;","categories":[{"name":"算法设计","slug":"算法设计","permalink":"https://rebiocoder.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"我爱小徐子"},{"title":"[算法设计]hash","slug":"法设计与分析-3","date":"2020-02-27T09:57:00.000Z","updated":"2021-01-05T04:10:18.429Z","comments":true,"path":"2020/02/27/法设计与分析-3/","link":"","permalink":"https://rebiocoder.github.io/2020/02/27/%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-3/","excerpt":"","text":"hash 基本问题 123456789101112131415161718192021#include &lt;cstdio&gt;#define MAXSIZE 1000void HashInt(int a[], int b[]) &#123; bool c[MAXSIZE] &#x3D; &#123; false &#125;; int m, n; printf(&quot;a,b数组元素的个数:&quot;); scanf(&quot;%d%d&quot;, &amp;m, &amp;n); for (int i &#x3D; 0; i &lt; m; ++i) &#123; int tmp; scanf(&quot;%d&quot;, &amp;tmp); a[i] &#x3D; tmp; c[tmp] &#x3D; true; &#125;&#x2F;&#x2F;空间换取时间 for (int j &#x3D; 0; j &lt; n; ++j) &#123; int tmp; scanf(&quot;%d&quot;, &amp;tmp); b[j] &#x3D; tmp; if (c[tmp]) printf(&quot;%d在a中存在&quot;,tmp); &#125;&#125; 字符串hash 大写字符hash核心代码: 123for(int i&#x3D;0; i&lt;len(s): ++i)&#123; id &#x3D; id*26 + (s[i]- &#39;A&#39;)&#125; 大小写字母均hash 1234567for(int i&#x3D;0; i&lt;len(s): ++i)&#123;if(s[i]&gt;&#39;A&#39; &amp;&amp; s[i]&lt;&#39;Z&#39;) id &#x3D; id*26 + (s[i]- &#39;A&#39;)else(s[i]&gt;&#39;a&#39; &amp;&amp; s[i]&lt;&#39;z&#39;) id &#x3D; id*52 + (s[i]-&#39;a&#39;) + 26&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"我爱小徐子"},{"title":"[算法设计]基本排序","slug":"法设计与分析-2","date":"2020-02-27T09:02:00.000Z","updated":"2021-01-05T04:17:51.369Z","comments":true,"path":"2020/02/27/法设计与分析-2/","link":"","permalink":"https://rebiocoder.github.io/2020/02/27/%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-2/","excerpt":"","text":"基本排序算法bubbleSort 关键点:一轮能够确定一个数,内层循环有:a[j]&gt;a[j+1],保证a[j+1]不溢出,第一轮循环需要从i=1开始,内层循环从j=0开始,j&lt;n-i 123456789101112void BubbleSort(int a[], int n) &#123;&#x2F;&#x2F;冒泡排序,a为数据数组, n为数组元素个数 int tmp; for (int i &#x3D; 1; i &lt; n; ++i) &#123; for (int j &#x3D; 0; j &lt; n - i; ++j) &#123; if (a[j] &gt; a[j + 1]) &#123;&#x2F;&#x2F;前一个元素大于后一个元素 tmp &#x3D; a[j]; a[j] &#x3D; a[j + 1]; a[j + 1] &#x3D; tmp; &#125; &#125; &#125;&#125; selectSort 关键点:与bubble刚好相反,它是从前往后排,所以关键在内层循环的int j=i开始点,而冒泡则是内层循环的j&lt;n-i结束的点 1234567891011121314void selectSort(int a[], int n) &#123;&#x2F;&#x2F;选择排序 for (int i &#x3D; 0; i &lt; n; ++i) &#123; int m &#x3D; i; for (int j &#x3D; i; j &lt; n; ++j ) &#123; if (a[m] &gt; a[j]) &#123; m &#x3D; j; &#125; &#125; int tmp &#x3D; a[i]; a[i] &#x3D; a[m]; a[m] &#x3D; tmp; &#125;&#125;","categories":[{"name":"算法设计","slug":"算法设计","permalink":"https://rebiocoder.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"我爱小徐子"},{"title":"[算法设计]求幂集","slug":"法分析","date":"2020-02-25T10:12:00.000Z","updated":"2021-01-05T04:18:03.253Z","comments":true,"path":"2020/02/25/法分析/","link":"","permalink":"https://rebiocoder.github.io/2020/02/25/%E6%B3%95%E5%88%86%E6%9E%90/","excerpt":"","text":"算法设计与分析(1)求幂集问题(穷举法) 1给定一个数n,求出从1-n的所有子集 法一:直接穷举 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#define MaxN 100 &#x2F;&#x2F;元素的最大值#define MaxSize 100 &#x2F;&#x2F;子集的最大值typedef struct&#123; int n; &#x2F;&#x2F;子集我的个数 int data[MaxSize][MaxN]; &#x2F;&#x2F;元素&#125;PsetType;void copy(int a[], int b[], int n)&#123;&#x2F;&#x2F;将a数组的值复制给b数组 for(int i&#x3D;0; i&lt;&#x3D;n; ++i) b[i] &#x3D; a[i];&#125;void pset(int n, PsetType &amp;p)&#123; int a[MaxN]; &#x2F;&#x2F;初始化 p.data[0][0] &#x3D; 0; p.n &#x3D; 1; &#x2F;&#x2F;初始化结束 for(int i&#x3D;1; i&lt;&#x3D;n; ++i)&#123; int m &#x3D; p.n; &#x2F;&#x2F;原幂集中子集的个数 for(int j&#x3D;0; j&lt;m; ++j)&#123; copy(p.data[j], a, p.data[j][0]); a[0]++; &#x2F;&#x2F;子集元素个数加1 a[a[0]] &#x3D; i; copy(a, p.data[p.n], a[0]); p.n++; &#125; &#125;&#125;void disp(PsetType p)&#123; for(int i&#x3D;0; i&lt;p.n; ++i)&#123; printf(&quot;&#123;&quot;); for(int j&#x3D;1; j&lt;&#x3D;p.data[i][0];++j)&#123; printf(&quot;%d&quot;,p.data[i][j]); &#125; printf(&quot;&#125;\\n&quot;); &#125;&#125;int main()&#123; PsetType p; int n &#x3D; 5; pset(n, p); disp(p); return 0;&#125; 法二:增量穷举法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#define MaxN 100 &#x2F;&#x2F;元素的最大值#define MaxSize 100 &#x2F;&#x2F;子集的最大值typedef struct&#123; int n; &#x2F;&#x2F;子集我的个数 int data[MaxSize][MaxN]; &#x2F;&#x2F;元素&#125;PsetType;void copy(int a[], int b[], int n)&#123;&#x2F;&#x2F;将a数组的值复制给b数组 for(int i&#x3D;0; i&lt;&#x3D;n; ++i) b[i] &#x3D; a[i];&#125;void pset(int n, PsetType &amp;p)&#123; int a[MaxN]; &#x2F;&#x2F;初始化 p.data[0][0] &#x3D; 0; p.n &#x3D; 1; &#x2F;&#x2F;初始化结束 for(int i&#x3D;1; i&lt;&#x3D;n; ++i)&#123; int m &#x3D; p.n; &#x2F;&#x2F;原幂集中子集的个数 for(int j&#x3D;0; j&lt;m; ++j)&#123; copy(p.data[j], a, p.data[j][0]); a[0]++; &#x2F;&#x2F;子集元素个数加1 a[a[0]] &#x3D; i; copy(a, p.data[p.n], a[0]); p.n++; &#125; &#125;&#125;void disp(PsetType p)&#123; for(int i&#x3D;0; i&lt;p.n; ++i)&#123; printf(&quot;&#123;&quot;); for(int j&#x3D;1; j&lt;&#x3D;p.data[i][0];++j)&#123; printf(&quot;%d&quot;,p.data[i][j]); &#125; printf(&quot;&#125;\\n&quot;); &#125;&#125;int main()&#123; PsetType p; int n &#x3D; 5; pset(n, p); disp(p); return 0;&#125; 示例图:","categories":[{"name":"算法设计","slug":"算法设计","permalink":"https://rebiocoder.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"我爱小徐子"},{"title":"离散结构笔记(1)","slug":"散结构笔记-1","date":"2020-02-21T05:37:39.000Z","updated":"2021-01-05T04:10:18.229Z","comments":true,"path":"2020/02/21/散结构笔记-1/","link":"","permalink":"https://rebiocoder.github.io/2020/02/21/%E6%95%A3%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-1/","excerpt":"","text":"命题: 能判断真假的陈述句称为命题 1231. 感叹句,祈使句,疑问句都不是命题2. 悖论不是命题3.判断结果不能唯一确定的不是命题 简单命题: 由一个简单陈述句组成(原子命题,不能再分) 复合命题: 简单命题 + 联结词 五种常用的联结词:否定,合取,析取,蕴涵,等价 否定: 非,并非 合取 合取词: “且” P 且 Q 当且仅当P和Q同时为真 12345P并且Q不但P而且Q既P又Q尽管P还Q虽然P但是Q 析取 析取词: 或 P或Q: 为假,当且仅当P和Q同时为假 分类: 相容或,排斥或 蕴涵词如果.. 那么 ..","categories":[],"tags":[],"author":"我爱小徐子"},{"title":"tornado与vue.js解决web一对一实时聊天（IM）","slug":"ornado与vue-js实现web一对一聊天","date":"2020-02-17T13:56:00.000Z","updated":"2021-01-05T04:10:17.829Z","comments":true,"path":"2020/02/17/ornado与vue-js实现web一对一聊天/","link":"","permalink":"https://rebiocoder.github.io/2020/02/17/ornado%E4%B8%8Evue-js%E5%AE%9E%E7%8E%B0web%E4%B8%80%E5%AF%B9%E4%B8%80%E8%81%8A%E5%A4%A9/","excerpt":"","text":"整个小项目最核心的通讯功能能够实现，效果如图： 记录一下这个阶段遇到的一些问题。 12345解决方案：前端vue.js+ajax后端django rest framework + tornado用户鉴权用JWTredis做系统缓存 一.前后端鉴权问题 1.django api鉴权 django通过鉴定http请求头的Authorization头部，进行鉴权。 当收到请求时，主要是以下方面的问题： 该token是否真实有效 该token所代表的用户是否为唯一登录 该token还有多久将会失效，若即将失效，则刷新token，同时要防止并发时，多次重复刷新 解决思路 对token发放的后端接口进行拦截，将/new_token得到的新token存入redis中，将/refresh_token得到的刷新token也存入redis中。 当得到一个带有Authorizaion请求头的请求时，首先通过decode该token，得到username和user_id（注意这里无论token是否失效都可以解码出来基本信息）,然后在redis中查询only_key，这里实际上就解决了1，2两个问题。 刷新token的问题，没有找到特别好的解决方案，采用的是，在redis中存储一个refresh_token，如果已经刷新，则不再刷新（防止重复刷新）。 2 . tornado api鉴权 tornado中没有django中中间件的概念，通过python的修饰器来进行鉴权，与django鉴权相同。 3.vue.js鉴权 采用router.beforeEach进行全局验证，需要验证的页面在meta中添加requiresAuth字段。 4.axios鉴权 新建一个api.js，create一个axios实例，在axios的拦截器中添加请求头Authorization。 所以api请求同一存放在api.js中，在组件中使用时，调用相关promise函数。由于axios是异步的，所以在long pool时，容易出现超时中断的情况。这里我不得不在vue中引入了jquery，用ajax做长轮询。（有好的解决方案也可以交流） 5.由于浏览器的限制，ajax请求容易出现cors，跨域请求失败。 在django中可以直接安装第三方组件来解决，在tornado中不行。 当请求方式为get和部分post时是不会出现cors错误的，但是当post，dataType为json时，这时为非简单请求中的一种，浏览器会自动发送一个options进行嗅探，查看server是否支持该ip的请求，在tornado中设置： 12345self.set_header(&#39;Access-Control-Allow-Origin&#39;, &#39;http:&#x2F;&#x2F;172.20.10.3:8080&#39;)self.set_header(&#39;Access-Control-Allow-Credentials&#39;, True)self.set_header(&#39;Access-Control-Allow-Headers&#39;, &#39;Origin, X-Requested-With, Content-Type, Accept, Authorization, athorization&#39;)self.set_header(&#39;Access-Control-Allow-Methods&#39;, &#39;POST, GET, PUT, DELETE&#39;) Access-Control-Allow-Origin中为前端ip+端口号，表示同意该ip的非简单请求。 二. tornado处理实时聊天消息 处理实时的信息，django自己的一套并不好用，django-channels加websocket虽然能实现简单的实时通信，但是效果并不好。tornado是一个异步web框架，处理实时消息，作为django的一个组件（这里说的并不准确，因为tornado的服务器是生产级服务器，可以直接生产部署，再加nginx反向代理，性能十分优越）。参考tornado中ajax聊天室demo（facebook工程师的demo，很值得读，编码规范也可以学习），使用redis做缓存在处理单对单的消息收发。 三。django与tornado的结合部署 官网文档有相关的例子，wsgi的结合部署，使用的是tornado的服务器。主要代码如下： 123456789101112wsgi_app &#x3D; wsgi.WSGIContainer( django.core.handlers.wsgi.WSGIHandler())tornado_app &#x3D; tornado.web.Application( [ (&#39;&#x2F;api&#x2F;v1&#x2F;all-message&#x2F;&#39;, ChatCacheApi.IndexMessageHandler), (&#39;&#x2F;api&#x2F;v1&#x2F;new-message&#x2F;&#39;, ChatCacheApi.NewMessageHandler), (&#39;&#x2F;api&#x2F;v1&#x2F;update-message&#x2F;&#39;, ChatCacheApi.UpdateMessageHandler), (&#39;.*&#39;, tornado.web.FallbackHandler, dict(fallback&#x3D;wsgi_app)), ])server &#x3D; tornado.httpserver.HTTPServer(tornado_app)server.listen(options.options.port, &#39;0.0.0.0&#39;)tornado.ioloop.IOLoop.current().start() 响应时，将会使用tornado server。 主要时记录一下思路，具有实现有点麻烦，有需要再记录。","categories":[{"name":"python","slug":"python","permalink":"https://rebiocoder.github.io/categories/python/"}],"tags":[{"name":"tornado","slug":"tornado","permalink":"https://rebiocoder.github.io/tags/tornado/"}],"author":"我爱小徐子"},{"title":"tornado与vue.js解决web一对一实时聊天（IM）","slug":"tornado与vue-js解决web一对一实时聊天（IM）","date":"2020-02-17T13:56:00.000Z","updated":"2021-01-05T03:55:11.288Z","comments":true,"path":"2020/02/17/tornado与vue-js解决web一对一实时聊天（IM）/","link":"","permalink":"https://rebiocoder.github.io/2020/02/17/tornado%E4%B8%8Evue-js%E8%A7%A3%E5%86%B3web%E4%B8%80%E5%AF%B9%E4%B8%80%E5%AE%9E%E6%97%B6%E8%81%8A%E5%A4%A9%EF%BC%88IM%EF%BC%89/","excerpt":"整个小项目最核心的通讯功能能够实现，效果如图：","text":"整个小项目最核心的通讯功能能够实现，效果如图： 整个小项目最核心的通讯功能能够实现，效果如图： demo图片 记录一下这个阶段遇到的一些问题。 解决方案：前端vue.js+ajax后端django rest framework + tornado用户鉴权用JWTredis做系统缓存 一.前后端鉴权问题 1.django api鉴权 django通过鉴定http请求头的Authorization头部，进行鉴权。 AZ9Y5E6OHP_HC_O0ZYNF_HS.png 当收到请求时，主要是以下方面的问题： 该token是否真实有效 该token所代表的用户是否为唯一登录 该token还有多久将会失效，若即将失效，则刷新token，同时要防止并发时，多次重复刷新 解决思路 对token发放的后端接口进行拦截，将/new_token得到的新token存入redis中，将/refresh_token得到的刷新token也存入redis中。 当得到一个带有Authorizaion请求头的请求时，首先通过decode该token，得到username和user_id（注意这里无论token是否失效都可以解码出来基本信息）,然后在redis中查询only_key，这里实际上就解决了1，2两个问题。 刷新token的问题，没有找到特别好的解决方案，采用的是，在redis中存储一个refresh_token，如果已经刷新，则不再刷新（防止重复刷新）。 2 . tornado api鉴权 tornado中没有django中中间件的概念，通过python的修饰器来进行鉴权，与django鉴权相同。 3.vue.js鉴权 采用router.beforeEach进行全局验证，需要验证的页面在meta中添加requiresAuth字段。 4.axios鉴权 新建一个api.js，create一个axios实例，在axios的拦截器中添加请求头Authorization。 所以api请求同一存放在api.js中，在组件中使用时，调用相关promise函数。由于axios是异步的，所以在long pool时，容易出现超时中断的情况。这里我不得不在vue中引入了jquery，用ajax做长轮询。（有好的解决方案也可以交流） 5.由于浏览器的限制，ajax请求容易出现cors，跨域请求失败。 在django中可以直接安装第三方组件来解决，在tornado中不行。 当请求方式为get和部分post时是不会出现cors错误的，但是当post，dataType为json时，这时为非简单请求中的一种，浏览器会自动发送一个options进行嗅探，查看server是否支持该ip的请求，在tornado中设置： 12345678910111213141516self.set\\_header(&#39;Access-Control-Allow-Origin&#39;, &#39;http:&#x2F;&#x2F;172.20.10.3:8080&#39;) self.set\\_header(&#39;Access-Control-Allow-Credentials&#39;, True) self.set\\_header(&#39;Access-Control-Allow-Headers&#39;, &#39;Origin, X-Requested-With, Content-Type, Accept, Authorization, athorization&#39;) self.set\\_header(&#39;Access-Control-Allow-Methods&#39;, &#39;POST, GET, PUT, DELETE&#39;) &#96;&#96;&#96;&#96;Access-Control-Allow-Origin&#96;中为前端ip+端口号，表示同意该ip的非简单请求。二. tornado处理实时聊天消息处理实时的信息，django自己的一套并不好用，&#96;django-channels&#96;加websocket虽然能实现简单的实时通信，但是效果并不好。tornado是一个异步web框架，处理实时消息，作为django的一个组件（这里说的并不准确，因为tornado的服务器是生产级服务器，可以直接生产部署，再加nginx反向代理，性能十分优越）。参考tornado中ajax聊天室demo（facebook工程师的demo，很值得读，编码规范也可以学习），使用redis做缓存在处理单对单的消息收发。三。django与tornado的结合部署官网文档有相关的例子，wsgi的结合部署，使用的是tornado的服务器。主要代码如下： wsgi_app = wsgi.WSGIContainer( django.core.handlers.wsgi.WSGIHandler())tornado_app = tornado.web.Application( [ (‘/api/v1/all-message/‘, ChatCacheApi.IndexMessageHandler), (‘/api/v1/new-message/‘, ChatCacheApi.NewMessageHandler), (‘/api/v1/update-message/‘, ChatCacheApi.UpdateMessageHandler), (‘.*‘, tornado.web.FallbackHandler, dict(fallback=wsgi_app)), ])server = tornado.httpserver.HTTPServer(tornado_app)server.listen(options.options.port, ‘0.0.0.0’)tornado.ioloop.IOLoop.current().start() ``` 响应时，将会使用tornado server。 主要时记录一下思路，具有实现有点麻烦，有需要再记录。","categories":[],"tags":[{"name":"tornado","slug":"tornado","permalink":"https://rebiocoder.github.io/tags/tornado/"},{"name":"python","slug":"python","permalink":"https://rebiocoder.github.io/tags/python/"}]},{"title":"tornado聊天室demo.py源码分析","slug":"tornado聊天室demo-py源码分析","date":"2020-02-14T10:25:00.000Z","updated":"2021-01-05T04:19:29.146Z","comments":true,"path":"2020/02/14/tornado聊天室demo-py源码分析/","link":"","permalink":"https://rebiocoder.github.io/2020/02/14/tornado%E8%81%8A%E5%A4%A9%E5%AE%A4demo-py%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"在tornado的源码之中有facebook的工程师写的demo,结构十分的优雅,可以用来学习.这篇文章主要是来分析chatdemo.py,tornado使用长轮询的方式建立聊天室的方式.不足之处,欢迎留言讨论. chatdemo.py的文件结构如下","text":"在tornado的源码之中有facebook的工程师写的demo,结构十分的优雅,可以用来学习.这篇文章主要是来分析chatdemo.py,tornado使用长轮询的方式建立聊天室的方式.不足之处,欢迎留言讨论. chatdemo.py的文件结构如下 在tornado的源码之中有facebook的工程师写的demo,结构十分的优雅,可以用来学习.这篇文章主要是来分析chatdemo.py,tornado使用长轮询的方式建立聊天室的方式.不足之处,欢迎留言讨论. chatdemo.py的文件结构如下: 1234D:. ├─chatdemo.py ├─static └─templates 首先来看chatdemo.py中的内容. 1234567class MessageBuffer(object): def \\_\\_init\\_\\_(self): \\# cond is notified whenever the message cache is updated self.cond &#x3D; tornado.locks.Condition() self.cache &#x3D; \\[\\] self.cache\\_size &#x3D; 200 首先是创建了一个messagebuffer,一个用来缓存聊天记录的类,在析构函数中有一个self.cond,它是一个tornado.locks.Condition(),具体看一下locks.condition的内容: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class \\_TimeoutGarbageCollector(object): &quot;&quot;&quot;Base class for objects that periodically clean up timed-out waiters. Avoids memory leak in a common pattern like: while True: yield condition.wait(short\\_timeout) print(&#39;looping....&#39;) &quot;&quot;&quot; def \\_\\_init\\_\\_(self) -&gt; None: self.\\_waiters &#x3D; collections.deque() \\# type: Deque\\[Future\\] self.\\_timeouts &#x3D; 0 def \\_garbage\\_collect(self) -&gt; None: \\# Occasionally clear timed-out waiters. self.\\_timeouts +&#x3D; 1 if self.\\_timeouts &gt; 100: self.\\_timeouts &#x3D; 0 self.\\_waiters &#x3D; collections.deque(w for w in self.\\_waiters if not w.done()) class Condition(\\_TimeoutGarbageCollector): def \\_\\_init\\_\\_(self) -&gt; None: super(Condition, self).\\_\\_init\\_\\_() self.io\\_loop &#x3D; ioloop.IOLoop.current() def \\_\\_repr\\_\\_(self) -&gt; str: result &#x3D; &quot;&lt;%s&quot; % (self.\\_\\_class\\_\\_.\\_\\_name\\_\\_,) if self.\\_waiters: result +&#x3D; &quot; waiters\\[%s\\]&quot; % len(self.\\_waiters) return result + &quot;&gt;&quot; def wait(self, timeout: Union\\[float, datetime.timedelta\\] &#x3D; None) -&gt; Awaitable\\[bool\\]: &quot;&quot;&quot;Wait for \\&#96;.notify\\&#96;. Returns a \\&#96;.Future\\&#96; that resolves \\&#96;\\&#96;True\\&#96;\\&#96; if the condition is notified, or \\&#96;\\&#96;False\\&#96;\\&#96; after a timeout. &quot;&quot;&quot; waiter &#x3D; Future() \\# type: Future\\[bool\\] self.\\_waiters.append(waiter) if timeout: def on\\_timeout() -&gt; None: if not waiter.done(): future\\_set\\_result\\_unless\\_cancelled(waiter, False) self.\\_garbage\\_collect() io\\_loop &#x3D; ioloop.IOLoop.current() timeout\\_handle &#x3D; io\\_loop.add\\_timeout(timeout, on\\_timeout) waiter.add\\_done\\_callback(lambda \\_: io\\_loop.remove\\_timeout(timeout\\_handle)) return waiter def notify(self, n: int &#x3D; 1) -&gt; None: &quot;&quot;&quot;Wake \\&#96;\\&#96;n\\&#96;\\&#96; waiters.&quot;&quot;&quot; waiters &#x3D; \\[\\] \\# Waiters we plan to run right now. while n and self.\\_waiters: waiter &#x3D; self.\\_waiters.popleft() if not waiter.done(): \\# Might have timed out. n -&#x3D; 1 waiters.append(waiter) for waiter in waiters: future\\_set\\_result\\_unless\\_cancelled(waiter, True) def notify\\_all(self) -&gt; None: &quot;&quot;&quot;Wake all waiters.&quot;&quot;&quot; self.notify(len(self.\\_waiters)) condition使用了_TimeoutGarbageCollector基类,在_TimeoutGarbageCollector中有一个用来存放future对象的self._waiters = collections.deque() # type: Deque[Future]队列,deque是一个双向队列,可以当队列来用,也可以当栈来使用.在conditoin中有一个wait函数,它的作用是等待一个通知,如果condition类被通知,则wait将会返回一个future对象,返回true.当condition.wait()被调用时,将会在condition类中_witer中存放进这个waiter,他是一个future对象.如果超时,IOLoop线程执行add_timeout,添加一个超时回调,请注意，从其他线程调用add_timeout是不安全的. 相反，您必须使用add_callback将控制权转移到IOLoop的线程，然后从那里调用add_timeout . waiter在完成时,可以执行一些回调,在这里执行一个lambda表达式,删除超时任务.on_timeout是一个闭包,当超时时间达到之后,如果waiter还没有set_result,则被添加进入_timeout中. notify用来进行通知,self._waiters.popleft()从左侧出队, 再来看messagebuffer中的get_message_since: 12345678910111213def get\\_messages\\_since(self, cursor): &quot;&quot;&quot;Returns a list of messages newer than the given cursor. \\&#96;\\&#96;cursor\\&#96;\\&#96; should be the \\&#96;\\&#96;id\\&#96;\\&#96; of the last message received. &quot;&quot;&quot; results &#x3D; \\[\\] for msg in reversed(self.cache): if msg\\[&quot;id&quot;\\] &#x3D;&#x3D; cursor: break results.append(msg) results.reverse() return results 返回一个消息列表.而add_message,在cache中补充新消息,同时进行notify_all.即把消息通知各所有的waiter 12345def add\\_message(self, message): self.cache.append(message) if len(self.cache) &gt; self.cache\\_size: self.cache &#x3D; self.cache\\[-self.cache\\_size :\\] self.cond.notify\\_all() 在发送一条新消息的处理函数中: 123456789101112131415class MessageNewHandler(tornado.web.RequestHandler): &quot;&quot;&quot;Post a new message to the chat room.&quot;&quot;&quot; def post(self): message &#x3D; &#123;&quot;id&quot;: str(uuid.uuid4()), &quot;body&quot;: self.get\\_argument(&quot;body&quot;)&#125; \\# render\\_string() returns a byte string, which is not supported \\# in json, so we must convert it to a character string. message\\[&quot;html&quot;\\] &#x3D; tornado.escape.to\\_unicode( self.render\\_string(&quot;message.html&quot;, message&#x3D;message) ) if self.get\\_argument(&quot;next&quot;, None): self.redirect(self.get\\_argument(&quot;next&quot;)) else: self.write(message) global\\_message\\_buffer.add\\_message(message) 有global_message_buffer.add_message(message)即将消息进行notify_all. 前端长轮询,tornado对应的处理函数如下,是整个demo的关键: 123456789101112131415161718192021222324class MessageUpdatesHandler(tornado.web.RequestHandler): &quot;&quot;&quot;Long-polling request for new messages. Waits until new messages are available before returning anything. &quot;&quot;&quot; async def post(self): cursor &#x3D; self.get\\_argument(&quot;cursor&quot;, None) messages &#x3D; global\\_message\\_buffer.get\\_messages\\_since(cursor) while not messages: \\# Save the Future returned here so we can cancel it in \\# on\\_connection\\_close. self.wait\\_future &#x3D; global\\_message\\_buffer.cond.wait() try: await self.wait\\_future except asyncio.CancelledError: return messages &#x3D; global\\_message\\_buffer.get\\_messages\\_since(cursor) if self.request.connection.stream.closed(): return self.write(dict(messages&#x3D;messages)) def on\\_connection\\_close(self): self.wait\\_future.cancel() 当请求到达之后,先查看cache中是否有未读的消息,如果有的话,只要连接还没有断开,就发送出去.如果没有,就hold住该请求,进入while.await self.wait_future,到这里异步处理完成,该请求挂在这里,等待self.wait_future产生结果,而不影响其他连接的生产,即不会发生阻塞.只有当有新消息达到之后,调用MessageNewHandler,执行了global_message_buffer.add_message(message),waiter才会产生set_result,产生返回.","categories":[{"name":"架构设计","slug":"架构设计","permalink":"https://rebiocoder.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"tornado","slug":"tornado","permalink":"https://rebiocoder.github.io/tags/tornado/"}]}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://rebiocoder.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"架构设计","slug":"架构设计","permalink":"https://rebiocoder.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"},{"name":"操作系统","slug":"操作系统","permalink":"https://rebiocoder.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"机器学习","slug":"机器学习","permalink":"https://rebiocoder.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"https://rebiocoder.github.io/categories/python/"},{"name":"算法设计","slug":"算法设计","permalink":"https://rebiocoder.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://rebiocoder.github.io/tags/Golang/"},{"name":"tornado","slug":"tornado","permalink":"https://rebiocoder.github.io/tags/tornado/"},{"name":"unix","slug":"unix","permalink":"https://rebiocoder.github.io/tags/unix/"},{"name":"机器学习","slug":"机器学习","permalink":"https://rebiocoder.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"python","slug":"python","permalink":"https://rebiocoder.github.io/tags/python/"}]}