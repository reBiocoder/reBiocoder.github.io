<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Echor</title>
  
  <subtitle>~~~</subtitle>
  <link href="https://rebiocoder.github.io/atom.xml" rel="self"/>
  
  <link href="https://rebiocoder.github.io/"/>
  <updated>2021-01-10T13:05:07.889Z</updated>
  <id>https://rebiocoder.github.io/</id>
  
  <author>
    <name>Echor</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Golang]defer与return的返回顺序问题</title>
    <link href="https://rebiocoder.github.io/2021/01/10/%E4%BD%86%E6%98%AFSV/"/>
    <id>https://rebiocoder.github.io/2021/01/10/%E4%BD%86%E6%98%AFSV/</id>
    <published>2021-01-10T11:45:00.000Z</published>
    <updated>2021-01-10T13:05:07.889Z</updated>
    
    <content type="html"><![CDATA[<p>defer在go中是一个全新的关键字，他的作用在于能够在go函数返回之后，延迟加载defer函数中的内容。这里对defer的作用进行如下测试：</p><ol><li>defer用于延迟加载<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func test2() &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">fmt.Printf(&quot;你好，世界！\n&quot;)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Printf(&quot;哈哈，我在外面\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">test2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输出结果如下：<br><img src="/images/pasted-14.png" alt="upload successful"></li></ol><p>2.函数中有多个defer函数<br>当函数中有多个defer时，从上到下，根据“先进后出”的原则 得到结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func test2() &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">fmt.Printf(&quot;你好，世界！\n&quot;)</span><br><span class="line">&#125;()</span><br><span class="line">defer func() &#123;</span><br><span class="line">fmt.Printf(&quot;我是第二个defer函数\n&quot;)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Printf(&quot;哈哈，我在外面\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; fmt.Printf(&quot;main函数里的name111: %s\n&quot;, name)</span><br><span class="line">&#x2F;&#x2F; myname :&#x3D; myfunc()</span><br><span class="line">&#x2F;&#x2F; fmt.Println(&quot;main 函数里的myname333: &quot;, myname)</span><br><span class="line">&#x2F;&#x2F; fmt.Printf(&quot;main函数里的name222: %s\n&quot;, name)</span><br><span class="line">&#x2F;&#x2F; fmt.Println(&quot;main 函数里的myname: &quot;, myname)</span><br><span class="line">test2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-15.png" alt="upload successful"></p><p>3.当defer与return均存在时，return先返回结果，再执行defer中的内容。实验如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var name string &#x3D; &quot;go&quot;</span><br><span class="line"></span><br><span class="line">func myfunc() string &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">name &#x3D; &quot;python&quot;</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Printf(&quot;myfunc 函数里的name: %s\n&quot;, name)</span><br><span class="line">return name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Printf(&quot;main函数里的name111: %s\n&quot;, name)</span><br><span class="line">myname :&#x3D; myfunc()</span><br><span class="line">fmt.Println(&quot;main 函数里的myname333: &quot;, myname)</span><br><span class="line">fmt.Printf(&quot;main函数里的name222: %s\n&quot;, name)</span><br><span class="line">fmt.Println(&quot;main 函数里的myname: &quot;, myname)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-16.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;defer在go中是一个全新的关键字，他的作用在于能够在go函数返回之后，延迟加载defer函数中的内容。这里对defer的作用进行如下测试：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;defer用于延迟加载&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    <category term="编程语言" scheme="https://rebiocoder.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Golang" scheme="https://rebiocoder.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Golang]基础知识</title>
    <link href="https://rebiocoder.github.io/2021/01/05/%E8%AE%BF%E9%97%AE/"/>
    <id>https://rebiocoder.github.io/2021/01/05/%E8%AE%BF%E9%97%AE/</id>
    <published>2021-01-05T05:20:00.000Z</published>
    <updated>2021-01-05T08:51:53.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>1.单个变量声明 <code>var name string</code> 这样声明一个变量，注意如果没有赋初始值，那么字符串初始值为空字符串“”，int为0，float为0.0，bool为false，指针类型为nil。</p><p>在go中，单引号和双引号有区别。在初始化变量时，如果右值带有小数点，那么建议带上类型float32。</p><p>2.多个变量一起声明，声明多个变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">old_name string</span><br><span class="line">age      int</span><br><span class="line">gender   float32</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>3.匿名变量的优点</p><ul><li>不分配内存，不占用内存空间</li><li>不需要你为命名无用的变量名而纠结</li><li>多次声明不会有任何问题</li></ul><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p><img src="/images/pasted-11.png" alt="upload successful"><br>在go中最好不要直接使用<code>int</code>给变量作为type，原因在于在32位机器上，int表示4个字节相当于int32，在64位机器上，int 表示8个字节，相当于int64。</p><p>二进制表示一个数：<code>0b110</code><br>八进制表示一个数： <code>0o14</code><br>十六进制表示一个数：<code>0xC</code></p><p>fmt格式化代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%b 格式化为二进制，</span><br><span class="line">%c unicode码值</span><br><span class="line">%d 十进制</span><br><span class="line">%o 八进制</span><br><span class="line">%x 十六进制</span><br><span class="line">%X 十六进制</span><br><span class="line">%U unicode格式</span><br><span class="line">%E 科学计数法</span><br><span class="line">%f 浮点数格式</span><br></pre></td></tr></table></figure><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>浮点数类型的值一般由整数部分、小数点“.”和小数部分组成。</p><p>其中，整数部分和小数部分均由10进制表示法表示。不过还有另一种表示方法。那就是在其中加入指数部分。指数部分由“E”或“e”以及一个带正负号的10进制数组成。比如，3.7E-2表示浮点数0.037。又比如，3.7E+1表示浮点数37。</p><p>有一点需要注意，在Go语言里，浮点数的相关部分只能由10进制表示法表示，而不能由8进制表示法或16进制表示法表示。比如，03.7表示的一定是浮点数3.7。</p><h3 id="float32-和-float64"><a href="#float32-和-float64" class="headerlink" title="float32 和 float64"></a>float32 和 float64</h3><p>Go语言中提供了两种精度的浮点数 float32 和 float64。</p><p>float32，也即我们常说的单精度，存储占用4个字节，也即4*8=32位，其中1位用来符号，8位用来指数，剩下的23位表示尾数。</p><p><img src="/images/pasted-12.png" alt="upload successful"></p><p>float64，也即我们熟悉的双精度，存储占用8个字节，也即8*8=64位，其中1位用来符号，11位用来指数，剩下的52位表示尾数。</p><p><img src="/images/pasted-13.png" alt="upload successful"></p><p>浮点数类型的取值范围可以从很微小到很巨大。浮点数取值范围的极限值可以在 math 包中找到：</p><ul><li>常量 math.MaxFloat32 表示 float32 能取到的最大数值，大约是 3.4e38；</li><li>常量 math.MaxFloat64 表示 float64 能取到的最大数值，大约是 1.8e308；</li><li>float32 和 float64 能表示的最小值分别为 1.4e-45 和 4.9e-324。</li></ul><p>注意浮点数表示精度的问题：</p><ol><li><p>float32的精度只能提供大约6个十进制数（表示后科学计数法后，小数点后6位）的精度</p></li><li><p>float64的精度能提供大约15个十进制数（表示后科学计数法后，小数点后15位）的精度</p></li></ol><h2 id="byte和rune"><a href="#byte和rune" class="headerlink" title="byte和rune"></a>byte和rune</h2><p>byte用来表示一个ASCII码字符，rune占有四个字节，表示一个unicode字符。</p><p>单引号用来表示字符，如果你使用双引号，就意味着你要定义一个字符串，赋值时与前面声明的前面会不一致，这样在编译的时候就会出错。</p><p>byte 和 uint8 没有区别，rune 和 uint32 没有区别，那为什么还要多出一个 byte 和 rune 类型呢？</p><p>理由很简单，因为uint8 和 uint32 ，直观上让人以为这是一个数值，但是实际上，它也可以表示一个字符，所以为了消除这种直观错觉，就诞生了 byte 和 rune 这两个别名类型。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串一般用双引号表示””，但是字符串也可以用``反引号，在反引号中，会忽略转义字符。</p><h2 id="数组与切片"><a href="#数组与切片" class="headerlink" title="数组与切片"></a>数组与切片</h2><p>数组是一个由固定长度的特定元素类型组成的序列。</p><p>注意：</p><ol><li>[3]int 与[4]int是不同的数据类型</li><li>如果在声明数组时，不想声明容量大小，可以使用<code>name := [...]int&#123;&#125;</code>类型的方式来让go自动识别大小。</li><li>可以给自定义的数组类型重命名，使用<code>type</code>关键字：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type arr [3]int</span><br><span class="line">var name arr &#x3D; arr &#123;1,2,3&#125;</span><br></pre></td></tr></table></figure><p>数组 与 切片 有相同点，它们都是可以容纳若干类型相同的元素的容器</p><p>也有不同点，数组的容器大小固定，而切片本身是引用类型，它更像是 Python 中的 list ，我们可以对它 append 进行元素的添加。</p><p>取切片值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">m :&#x3D; make([]int, 2, 10)</span><br><span class="line">fmt.Println(m)</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;\n&quot;)</span><br><span class="line">myarr :&#x3D; []int&#123;&#125;</span><br><span class="line">fmt.Println(myarr)</span><br><span class="line">myarr &#x3D; append(myarr, 2)</span><br><span class="line">fmt.Println(myarr)</span><br><span class="line">myarr &#x3D; append(myarr, []int&#123;7, 8, 9&#125;...) &#x2F;&#x2F;解包切片</span><br><span class="line">fmt.Println(myarr)</span><br><span class="line">myarr &#x3D; append([]int&#123;100&#125;, myarr...) &#x2F;&#x2F;在第一个位置插入</span><br><span class="line">fmt.Println(myarr)</span><br><span class="line">fmt.Println(myarr[len(myarr)-1])</span><br><span class="line">myarr &#x3D; append(myarr[0:len(arr)-1], append([]int&#123;520, 520&#125;, myarr[len(myarr)-1:]...)...) &#x2F;&#x2F;在最后一个元素之前插入元素</span><br><span class="line">fmt.Println(myarr)</span><br></pre></td></tr></table></figure><h2 id="字典与布尔类型"><a href="#字典与布尔类型" class="headerlink" title="字典与布尔类型"></a>字典与布尔类型</h2><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典的下标读取可以返回两个值，使用第二个返回值都表示对应的 key 是否存在，若存在ok为true，若不存在，则ok为false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;********************************************</span><br><span class="line">var socres map[string]int &#x3D; map[string]int&#123;&quot;english&quot;: 92, &quot;chinese&quot;: 85&#125;</span><br><span class="line">fmt.Println(socres)</span><br><span class="line">users :&#x3D; make(map[string]int) &#x2F;&#x2F;初始化一个字典</span><br><span class="line">fmt.Println(users)</span><br><span class="line">users[&quot;Echor&quot;] &#x3D; 19 &#x2F;&#x2F;添加元素</span><br><span class="line">users[&quot;zhou&quot;] &#x3D; 20</span><br><span class="line">fmt.Println(users)</span><br><span class="line">users[&quot;zhou&quot;] &#x3D; 21 &#x2F;&#x2F;添加重复键元素</span><br><span class="line">fmt.Println(users)</span><br><span class="line">fmt.Println(users[&quot;zhou&quot;]) &#x2F;&#x2F;得到存在元素</span><br><span class="line">_, ok :&#x3D; users[&quot;sss&quot;]</span><br><span class="line">fmt.Println(ok)       &#x2F;&#x2F;得到不存在元素</span><br><span class="line">delete(users, &quot;zhou&quot;) &#x2F;&#x2F;删除存在元素</span><br><span class="line">fmt.Println(users)</span><br><span class="line">delete(users, &quot;sss&quot;) &#x2F;&#x2F;删除不存在元素</span><br><span class="line">fmt.Println(users)</span><br><span class="line">   fmt.Println(users)</span><br><span class="line">for k, v :&#x3D; range socres &#123; &#x2F;&#x2F;循环得到键值对</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>关于布尔值，无非就两个值：true 和 false。只是这两个值，在不同的语言里可能不同。</p><p>而在 Go 中，真值用 true 表示，不但不与 1 相等，并且更加严格，不同类型无法进行比较，而假值用 false 表示，同样与 0 无法比较。</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针的概念学了c语言将不难理解，变量分为普通变量和指针变量；</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if-else-if-else-判断"><a href="#if-else-if-else-判断" class="headerlink" title="if-else if- else 判断"></a>if-else if- else 判断</h3><p>在golang中<code>if-else if -else</code>有以下特点：</p><ol><li>在if之后可以接一个表达式</li><li><code>&#125;else&#123;</code>  <code>&#125;else if&#123;</code>必须和左右括号在同一行</li></ol><h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h3><p>注意：</p><ol><li>在case后面可以接多个判断条件，他们的关系是”或“；</li><li>可以使用fallthrough进行穿透，但是只能穿透一层；</li><li>当条件都不匹配时，匹配default</li></ol><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for 循环的基本模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for [condition |  ( init; condition; increment ) | Range]</span><br><span class="line">&#123;</span><br><span class="line">   statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>在go中没有while，通过<code>for&#123;&#125;</code>（在for后面不加任何表达式来控制无线循环）</li><li><code>for range</code>遍历可以可迭代对象。<code>for range</code>的for后面不能添加任何表达式</li></ol><h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><p>不建议使用，使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goto flag:</span><br><span class="line">****</span><br><span class="line">flag:</span><br><span class="line">****</span><br><span class="line">    ****</span><br></pre></td></tr></table></figure><h3 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h3><ol><li>延迟调用。defer 的用法很简单，只要在后面跟一个函数的调用，就能实现将这个 xxx 函数的调用延迟到当前函数执行完后再执行。</li><li>多个defer满足”先进后出“的条件</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;变量声明&quot;&gt;&lt;a href=&quot;#变量声明&quot; class=&quot;headerlink&quot; title=&quot;变量声明&quot;&gt;&lt;/a&gt;变量声明&lt;/h2&gt;&lt;p&gt;1.单个变量声明 &lt;code&gt;var name string&lt;/code&gt; 这样声明一个变量，注意如果没有赋初始值，那么字符</summary>
      
    
    
    
    <category term="编程语言" scheme="https://rebiocoder.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Golang" scheme="https://rebiocoder.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>tornado后端session用户认证鉴权解决方案</title>
    <link href="https://rebiocoder.github.io/2021/01/05/tornado%E5%90%8E%E7%AB%AFsession%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E9%89%B4%E6%9D%83%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://rebiocoder.github.io/2021/01/05/tornado%E5%90%8E%E7%AB%AFsession%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E9%89%B4%E6%9D%83%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2021-01-05T02:39:00.000Z</published>
    <updated>2021-01-05T02:41:37.713Z</updated>
    
    <content type="html"><![CDATA[<p>tornado框架自身没有集成session鉴权，但是对cookie支持良好。由于现在前端vue部署在一个端口上，后端tornado分布式应用部署在多个端口上，这就会导致浏览器的跨域问题产生（url不同，即协议，域名，端口三者有不相同的地方）。</p><p>在前后端分离的项目中，由于页面的路由跳转由vue控制，后端应用只提供数据。这样就会使鉴权任务变得较为复杂。一个比较良好的解决思路是，在前端需要鉴权才能访问的路由中添加一个后端异步请求，该请求用来判断用户是否登录，这样来判断用户当前是否有权限访问该页面。同时，后端需要    登录才能访问的接口，用修饰器来判断用户当前是否登录。下面提供一种tornado实现session的解决方案。<br>在新建一个HTTP请求时，需要初始化一个session类，该类应该实现以下功能：</p><ol><li><p>能够从请求头的cookie中得到session_id；</p></li><li><p>能够生成一个全新的session_id，并将其返回给client；</p></li><li><p>若server得到的session_id失效，则清空client的cookie；</p></li><li><p>若server得到的sess_id有效，则从redis中取出对应的用户信息</p></li></ol><p>在一个HTTP请求结束时，需要判断，当前这个链接是否为”登录成功“的API，如果是，则需要将对应的用户信息存储到redis中，并生成一个新的session_id返回给用户。</p><p>代码如下：<br>BaseHandler</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class BaseHandler(web.RequestHandler):</span><br><span class="line">    def initialize(self):</span><br><span class="line">        self.session_save_tag &#x3D; False</span><br><span class="line">        self.session &#x3D; None</span><br><span class="line"></span><br><span class="line">    async def prepare(self):</span><br><span class="line">        await self.init_session()</span><br><span class="line">        if get_config().session[&#39;session_key_name&#39;] in self.session:</span><br><span class="line">            self.current_user &#x3D; LoginUser(self.session[get_config().session[&#39;session_key_name&#39;]])</span><br><span class="line">    def on_finish(self):</span><br><span class="line">        if self.session is not None and self.session_save_tag:</span><br><span class="line">            get_loop().add_callback(self.session.save)</span><br><span class="line">        get_logger().info(&quot;[一次HTTP请求结束]&quot;)</span><br><span class="line">        async def init_session(self):</span><br><span class="line">        if not self.session:</span><br><span class="line">            self.session &#x3D; Session(self)</span><br><span class="line">            await self.session.init_fetch()</span><br><span class="line">            </span><br><span class="line">    def save_session(self):</span><br><span class="line">        self.session_save_tag &#x3D; True</span><br><span class="line">        self.session.generate_session_id()</span><br><span class="line">        get_logger().info(&quot;【登录】生成session_id结束&quot;)</span><br><span class="line"></span><br><span class="line">    def save_login_user(self, user: dict):</span><br><span class="line">        login_user &#x3D; LoginUser(None)</span><br><span class="line">        login_user[&#39;username&#39;] &#x3D; user.get(&quot;username&quot;, &quot;&quot;)</span><br><span class="line">        login_user[&#39;email&#39;] &#x3D; user.get(&quot;email&quot;, &quot;&quot;)</span><br><span class="line">        login_user[&#39;phone&#39;] &#x3D; user.get(&quot;phone&quot;, &quot;&quot;)</span><br><span class="line">        self.session[get_config().session[&#39;session_key_name&#39;]] &#x3D; login_user</span><br><span class="line">        self.current_user &#x3D; login_user</span><br><span class="line">        self.save_session()</span><br></pre></td></tr></table></figure><p>login API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class LoginHandler(BaseHandler):</span><br><span class="line">    async def post(self):</span><br><span class="line">        try:</span><br><span class="line">            username &#x3D; self.data[&#39;username&#39;]</span><br><span class="line">            password &#x3D; self.data[&#39;password&#39;]</span><br><span class="line">            doc_user &#x3D; await get_one_data(self.mongodb_manager, Config.mongodb_config[&#39;user_info&#39;],</span><br><span class="line">                                          &#123;&#39;username&#39;: username&#125;)</span><br><span class="line">            print(doc_user)</span><br><span class="line">            if doc_user is not None and password &#x3D;&#x3D; doc_user[&#39;password&#39;]:</span><br><span class="line">                self.save_login_user(doc_user)</span><br><span class="line">                get_logger().info(&quot;登录成功,用户信息已经保存&quot;)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            error &#x3D; traceback.format_exc()</span><br><span class="line">            get_logger().error(&quot;login fail[&#123;&#125;]:&#123;&#125;&quot;.format(e, error))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;tornado框架自身没有集成session鉴权，但是对cookie支持良好。由于现在前端vue部署在一个端口上，后端tornado分布式应用部署在多个端口上，这就会导致浏览器的跨域问题产生（url不同，即协议，域名，端口三者有不相同的地方）。&lt;/p&gt;
&lt;p&gt;在前后端分离的</summary>
      
    
    
    
    <category term="架构设计" scheme="https://rebiocoder.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="tornado" scheme="https://rebiocoder.github.io/tags/tornado/"/>
    
  </entry>
  
  <entry>
    <title>微服务设计阅读学习</title>
    <link href="https://rebiocoder.github.io/2021/01/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/"/>
    <id>https://rebiocoder.github.io/2021/01/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-01-04T14:09:00.000Z</published>
    <updated>2021-01-04T14:11:26.166Z</updated>
    
    <content type="html"><![CDATA[<p>微服务的概念网上都有，各种博客都有解释。但是自己没有上手写代码，没有做工程项目，实际上是很难体会的。 微服务与SOA（面向服务的架构）的区别主要在于微服务中每个服务是一个独立的进程，它能够被独立的部署。若该服务宕机，并不影响整个系统中其他服务的正常运行。</p><p>在开始尝试做一个新的系统时，若常用微服务的方式，则需要使用限界上下文划分微服务边界。限界上下文指的是一个由显式边界限定的特定职责。如果你想要从一个限界上下文中获取信息，或者向其发起请求，需要使用模型和它的显式边界进行通信。实际上寻找限界上下文边界就是将整个业务逻辑进行一个粗粒度的划分。对于一个新系统而言，过早划分很容易错误判断服务之间的边界，按照书中内容所说，很多时候，将一个已有的代码库划分成微服务，要比从头开始构建微服务简单得多。</p><p>当你在思考组织内的限界上下文时，不应该从共享数据的角度来考虑，而应该从这些上下文能够提供的功能来考虑。服务与服务之间如果能够做到低耦合，高内聚，那么这就是一个好的微服务系统。实际上，要做到低耦合，高内聚还是很困难的，在工程项目中很可能遇到一份代码需要多次拷贝使用，当遇到这种情况时，就需要注意DRY（don’t repeat yourself）。应该考虑使用更好的设计模式来避免这种情况，因为很容易出现，一个地方被修改了，但是另一个地方忘记修改的情况。</p><p>服务集成是微服务相关技术中最重要的一个问题，按照作者的话来说：做得好的话，你的微服务可以保持自治性，你也可以独立地修改和发布它们；但做得不好的话会带来灾难。在选择集成方式时，需要注意以下几个原则：1.避免破坏性修改 2. 保证API的技术无关系3.使你的服务易于消费方使用4.隐藏内部实现细节。服务之间的通信可以分为同步和异步两种：如果使用同步通信，发起一个远程服务调用后，调用方会阻塞自己并等待整个操作的完成。如果使用异步通信，调用方不需要等待操作完成就可以返回，甚至可能不需要关心这个操作完成与否。这两种不同的通信模式有着各自的协作风格，即请求/响应或者基于事件。对于请求/响应来说，客户端发起一个请求，然后等待响应。这种模式能够与同步通信模式很好地匹配，但异步通信也可以使用这种模式。我可以发起一个请求，然后注册一个回调，当服务端操作结束之后，会调用该回调。对于使用基于事件的协作方式来说，情况会颠倒过来。客户端不是发起请求，而是发布一个事件，然后期待其他的协作者接收到该消息，并且知道该怎么做。</p><p>服务与服务之间常见有两种常见的架构风格：编排与协同。</p><p><img src="/images/pasted-8.png" alt="upload successful"></p><p> 对于上图用户注册这样一个业务逻辑，如果用编排的风格来设计服务，我们可以得到如下的架构图：</p><p><img src="/images/pasted-9.png" alt="upload successful"><br>很显然，若编排的架构使用的是同步通信的机制，即请求/响应的协作方式，那么我们能够得到每一个服务返回的结果。当然，编排的架构也能使用基于回调的异步通信。编排架构的缺点在于，客户服务承担了太多的职责，而剩下的三个服务按作者的话来说：会成为贫血的CRUD服务。</p><p>如果采用协同的架构风格，我们可以得到下面这个架构图：</p><p><img src="/images/pasted-10.png" alt="upload successful"></p><p>可以仅仅从客户服务中使用异步的方式触发一个事件，该事件名可以叫作“客户创建”。电子邮件服务、邮政服务及积分账户可以简单地订阅这些事件并且做相应处理，如上图所示，这种方法能够显著地消除耦合。使用协同的方式组织服务，很显然必定是异步的。使用这种发布-订阅的模式，是当前非常流行的一种通信模式，典型的就是消息队列，比如RabbitMQ。这种模式能够很大程度的在服务之间进行解耦，但是它的一个问题在于无法检测服务是否成功执行，比如电子邮件服务出现问题，无法发送邮件，此时整个系统是否能够检测到该问题，并进行处理。一个常见的解决方案是构建一个与业务逻辑流程图相匹配的监控系统。实际的监控活动是针对每个服务的，但最终需要把监控的结果映射到业务流程中。针对请求响应的协同方式，常用有两种技术：RPC和REST（表征性状态转移）风格的HTTP。针对基于事件的协同方式，一般采用消息队列来实现。</p><p>微服务的部署相对于单体应用来说，也是一个较为复杂的问题。CI/CD（持续集成/持续部署）是当前非常重要的一种思想。按照书中所说，判断你的项目是否CI，可以通过回答一下几个问题来判断：1.你是否每天签入代码到主线？2.你是否有一组测试来验证修改？3.当构建失败后，团队是否把修复CI当作第一优先级的事情来做？我个人感觉CI/CD应该是用来解决开发和运维之间的矛盾，应该需要一个DevOps系统来实现这种思想。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;微服务的概念网上都有，各种博客都有解释。但是自己没有上手写代码，没有做工程项目，实际上是很难体会的。 微服务与SOA（面向服务的架构）的区别主要在于微服务中每个服务是一个独立的进程，它能够被独立的部署。若该服务宕机，并不影响整个系统中其他服务的正常运行。&lt;/p&gt;
&lt;p&gt;在开</summary>
      
    
    
    
    <category term="架构设计" scheme="https://rebiocoder.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>unix环境高级编程：高级I/O理解</title>
    <link href="https://rebiocoder.github.io/2021/01/04/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%9A%E9%AB%98%E7%BA%A7I-O%E7%90%86%E8%A7%A3/"/>
    <id>https://rebiocoder.github.io/2021/01/04/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%9A%E9%AB%98%E7%BA%A7I-O%E7%90%86%E8%A7%A3/</id>
    <published>2021-01-04T13:58:00.000Z</published>
    <updated>2021-01-04T14:02:25.397Z</updated>
    
    <content type="html"><![CDATA[<p>在网络通信中，数据的传输大部分基于socket（socket位于TCP/UDP与HTTP协议之间，当然socket也可以利用SOCK_RAW套接字提供一个数据报接口，用于直接访问下面的网络层，当使用SOCKT_RAW套接字时，应用程序应该构造自己的协议头部）。在unix系统中，将socket的操作抽象为文件的读，写，异常，即一个socket对象可以对应为一个文件描述符(fd)。所以网络I/O与磁盘读写O/I可以属于同一层次上要考虑的问题。</p><p>在考虑具体问题之前，首先要明确一个概念，阻塞与非阻塞是对于进程而言：当一个进程想要read一个文件描述符(fd)时，若fd的读缓冲区没有数据，此时进程将会阻塞，直到缓冲区中有数据可以使用，此时进程才会继续向下运行，这种情况便是阻塞I/O。对非阻塞I/O而言，当fd的读缓冲区中没有数据时，进程并不会阻塞在此处，而是立即返回错误，表示该操作如继续执行将会阻塞。下图是一个非阻塞I/O的例子(a.out)</p><p>    <br><img src="/images/pasted-3.png" alt="upload successful"></p><p>执行以下代码：</p><p><code>./a.out &lt; /etc/services 2&gt;stderr.out</code></p><p>可以得到如下结果：</p><p><img src="/images/pasted-4.png" alt="upload successful"></p><p>其中35对应的是EAGAIN信号，显然一次输出到终端的数据是有限的，当数据不能write到终端时，进程并没有阻塞，而是返回信号EAGAIN,表明当前写缓冲区已满， 以上代码便是一种轮询操作。</p><p>考虑如下一种场景：当该进程必须要从两个或多个fd中同时读取数据时，在这种情况下，我们不能将进程阻塞在任何一个fd的read方法上，原因是，另一个fd可能已经准备好read了，但进程阻塞，无法对其进行任何操作。为了能够使进程同时处理多个fd，我们的第一个想是fork子进程，或者用多线程同时阻塞处理。但这在实现上较为繁琐，且占用资源。另外，也可以用轮询的方法来遍历fd的状态。第三种方法是用异步I/O：进程告诉内核，当fd准备好可以进行I/O时，用一个信号通知进程，这种方法存在的问题在于：每个进程只能有一个信号，如果信号对多个fd都起作用，那么进程在收到该信号时，无法判断是哪个fd准备就绪。以上三种方法或多或少都有问题，我们主要考虑I/O多路转接技术。<br>I/O多路转接技术想要实现的作用是：将想监听的fd加入一个列表，用某个函数来监听这个列表，当列表中有fd准备就绪时，返回准备就绪的fd给进程使用。select函数和poll函数便是实现该功能。select函数如下：<br><img src="/images/pasted-5.png" alt="upload successful"></p><p>传给select的参数告诉内核：</p><p>我们所关心的描述符</p><p>对于每个描述符，我们所关心的条件</p><p>愿意等待多长时间</p><p>select将会返回：</p><p>已经准备好的描述符的总数量</p><p>对于读，写，异常，哪些描述符已经准备好了。</p><p>该函数返回的fd一定是准备就绪的，调用对应的read,write函数一定不会发生阻塞。select函数的具体实现过程：</p><p><img src="/images/pasted-6.png" alt="upload successful"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1.</span> 从用户态copy fd_set到内核空间</span><br><span class="line"><span class="number">2.</span> 注册回调函数pollwait（将进程挂到每个socket的等待队列中，</span><br><span class="line">当socket准备好后（执行mask状态码进行判断，再唤醒进程））</span><br><span class="line"><span class="number">3.</span> 内核遍历fd，调用每一个fd的poll方法，返回socket的mask状态掩码，即</span><br><span class="line">现在准备好了没有，给fd_set赋值</span><br><span class="line"><span class="number">4.</span>当无可读写mask码时，select睡眠（On Linux, select() modifies </span><br><span class="line">timeout to reflect the amount of time <span class="keyword">not</span> slept），等睡眠时间到，</span><br><span class="line">再次醒来轮询fd_set（内核态轮询）</span><br><span class="line"><span class="number">5.</span> 有值时返回fd_set，将其copy到用户空间</span><br><span class="line"><span class="number">6.</span> 用户进程变为运行态，循环fd_set，得到准备好的fd。</span><br></pre></td></tr></table></figure><p>内核创建一个epoll对象，epoll_ctl函数向epoll对象中添加需要监听的fd，当fd准备就绪时，中断程序会操作epoll对象，而不是操作进程。当进程执行到epoll_wait时，如果就绪列表存在已经准备好的fd，进程将会被唤醒。</p><p><img src="/images/pasted-7.png" alt="upload successful"></p><p>epoll的作用是提升事件循环查询“io事件”的效率，他允许用户进程同时监听多个文件描述符的io事件即io多路复用。同时epoll在实现上是十分高效的，相对于poll/select，epoll使得进程可以监控更多的文件描述符。epoll采用注册机制，在内核中保存用户关注的文件描述符（红黑树保存），不像select一样每次都需要传入所有的文件描述符，效率更高(减少了从用户空间向内核空间的拷贝)。epoll不像select一样会在内核中轮询所有的文件描述符（低效的），epoll会在不同文件描述符对应的设备的等待队列中添加一个回调函数，在回掉函数中将对应的文件描述符添加至epoll的rdlist队列（高效的），当进程调用epoll_wait时，内核检查该队列是否为空，如果是空则阻塞进程，如果不为空则将该队列拷贝至用户空间，并返回该函数。epoll的两种触发模式：</p><p>1.水平触发：只要fd仍然可读或写，每次调用epoll_wait都会返回该文件描述符；</p><p>2.边缘触发：只fd仍然可读或写，每次调用epoll_wait只会返回一次该文件描述符；</p><p>注意异步I/O与非阻塞I/O的区别，异步I/O，需要用回调函数来处理，fd准备好之后的情况，比较复杂。而非阻塞则是在fd的read，write操作时，一定可以立即得到结果，不会阻塞进程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在网络通信中，数据的传输大部分基于socket（socket位于TCP/UDP与HTTP协议之间，当然socket也可以利用SOCK_RAW套接字提供一个数据报接口，用于直接访问下面的网络层，当使用SOCKT_RAW套接字时，应用程序应该构造自己的协议头部）。在unix系统</summary>
      
    
    
    
    <category term="操作系统" scheme="https://rebiocoder.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="unix" scheme="https://rebiocoder.github.io/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>机器学习（1）</title>
    <link href="https://rebiocoder.github.io/2020/06/01/%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    <id>https://rebiocoder.github.io/2020/06/01/%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/</id>
    <published>2020-06-01T02:27:00.000Z</published>
    <updated>2021-01-05T04:10:18.129Z</updated>
    
    <content type="html"><![CDATA[<p>1.监督学习</p><p>回归： 预测连续值</p><p>分类：预测离散值</p><p>2.无监督学习</p><p>聚类算法</p><p>鸡尾酒算法</p><hr><p>梯度下降<br>![QOLJD78`A_BYQ_DIY_DGNWG.png](<a href="https://i.loli.net/2020/06/01/ugZyM5nDhRqdTUX.png">https://i.loli.net/2020/06/01/ugZyM5nDhRqdTUX.png</a>)</p><p>正确更新方式是同时更新x1和x2</p><p>计算偏导数<br><img src="https://i.loli.net/2020/06/01/mr3ni7wShMvR4uc.png" alt="3~O_PS3D6DF_JEAU5_NG6AY.png"></p><hr><p>logistics 函数<br>![C_CNR7D`BWNRDQI27~R_AZF.png](<a href="https://i.loli.net/2020/06/01/KG52sOlePuikzRM.png">https://i.loli.net/2020/06/01/KG52sOlePuikzRM.png</a>)</p><p>logistics代价函数<br><img src="https://i.loli.net/2020/06/01/oQrBApX6wTaWz35.png" alt="I2_EVOY__ZBQVK_ST_KM_XR.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.监督学习&lt;/p&gt;
&lt;p&gt;回归： 预测连续值&lt;/p&gt;
&lt;p&gt;分类：预测离散值&lt;/p&gt;
&lt;p&gt;2.无监督学习&lt;/p&gt;
&lt;p&gt;聚类算法&lt;/p&gt;
&lt;p&gt;鸡尾酒算法&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;梯度下降&lt;br&gt;![QOLJD78`A_BYQ_DIY_DGNWG.png](&lt;a hre</summary>
      
    
    
    
    <category term="机器学习" scheme="https://rebiocoder.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://rebiocoder.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>二叉树中序遍历（栈）</title>
    <link href="https://rebiocoder.github.io/2020/04/22/%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://rebiocoder.github.io/2020/04/22/%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2020-04-22T08:09:00.000Z</published>
    <updated>2021-01-05T04:10:18.325Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode94<br>问题：<br>栈的方式实现二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">def middelTravel(self, r):</span><br><span class="line">    stack, ret &#x3D; [], []</span><br><span class="line">    root &#x3D; r</span><br><span class="line">    while stack or root:</span><br><span class="line">    if root:</span><br><span class="line">        stack.append(root)</span><br><span class="line">        root &#x3D; root.left</span><br><span class="line">      else:</span><br><span class="line">        s &#x3D; stack.pop()</span><br><span class="line">         ret.append(s.val)</span><br><span class="line">         root &#x3D; s.right</span><br><span class="line">    return ret</span><br></pre></td></tr></table></figure><p>关键点：<br>1.根节点先入栈，然后以左节点为根节点，直到左节点为空，将根节点出栈。 以右节点为根节点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;leetcode94&lt;br&gt;问题：&lt;br&gt;栈的方式实现二叉树&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa</summary>
      
    
    
    
    
    <category term="算法" scheme="https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树子树</title>
    <link href="https://rebiocoder.github.io/2020/04/22/%E5%8F%89%E6%A0%91%E5%AD%90%E6%A0%91/"/>
    <id>https://rebiocoder.github.io/2020/04/22/%E5%8F%89%E6%A0%91%E5%AD%90%E6%A0%91/</id>
    <published>2020-04-22T07:36:00.000Z</published>
    <updated>2021-01-05T04:10:18.177Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode572<br>问题：判断t是否为s的子树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">python解决方案</span><br><span class="line">class TreeNode:</span><br><span class="line">def __init__(self):</span><br><span class="line">    self.val &#x3D; val</span><br><span class="line">    self.left &#x3D; None</span><br><span class="line">    self.right &#x3D; None</span><br><span class="line">class Solution:</span><br><span class="line">def isSubtitle(t,s):</span><br><span class="line">    def up(t):</span><br><span class="line">    return (t.val, up(t.left), up(t.right)) if t else None</span><br><span class="line">    return str(up(t))  in str(up(s))</span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>元组中的元素位置不会发生变化</li><li>print(“a” in “ab”) 返回true</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;leetcode572&lt;br&gt;问题：判断t是否为s的子树&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    
    <category term="算法" scheme="https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树右视图</title>
    <link href="https://rebiocoder.github.io/2020/04/22/%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <id>https://rebiocoder.github.io/2020/04/22/%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE/</id>
    <published>2020-04-22T06:33:00.000Z</published>
    <updated>2021-01-05T04:10:18.277Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树右视图（leetcode 199）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">def __init__(self,x):</span><br><span class="line">      self.val &#x3D; x</span><br><span class="line">      self.left &#x3D; None</span><br><span class="line">      self.right &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">def rightDideView(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">    d &#x3D; &#123;&#125;</span><br><span class="line">      def f(r,i):</span><br><span class="line">         if r:</span><br><span class="line">          d[i] &#x3D; r.val</span><br><span class="line">            f(r.left, i+1)</span><br><span class="line">            f(r.right, i+1)</span><br><span class="line">      f(root,0)</span><br><span class="line">      return [*d.values()]</span><br></pre></td></tr></table></figure><p>思路：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先序遍历，注意rightSideView(r-&gt;left, i+1)与rightSideView(r-right, i+1)中的i相同，由此可以知道，字典中存储的数据一定是每层的最后一个数据</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;二叉树右视图（leetcode 199）&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    
    <category term="算法" scheme="https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>UML类图</title>
    <link href="https://rebiocoder.github.io/2020/04/16/ML%E7%B1%BB%E5%9B%BE/"/>
    <id>https://rebiocoder.github.io/2020/04/16/ML%E7%B1%BB%E5%9B%BE/</id>
    <published>2020-04-16T03:39:18.000Z</published>
    <updated>2021-01-05T04:10:17.769Z</updated>
    
    <content type="html"><![CDATA[<ol><li>类图基本属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+表示public</span><br><span class="line">-表示private</span><br><span class="line">#表示protected</span><br></pre></td></tr></table></figure></li><li>类与类的基本关系</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.依赖关系</span><br><span class="line">定义：有两个元素x和y，如果修改x的定义可能会引起对y的定义的修改，则称y依赖与元素x，用带箭头的虚线表示依赖关系，箭头指向被依赖的对象。</span><br><span class="line"></span><br><span class="line">2.泛化关系</span><br><span class="line">泛化关系就是子类与父类之间的继承关系。用带空心箭头的实线表示，箭头指向父类</span><br><span class="line"></span><br><span class="line">3.关联关系</span><br><span class="line">关联关系可以理解为ER图中的实体关系，用实现表示，上方标识数字来进行确认。</span><br><span class="line"></span><br><span class="line">4.聚合关系</span><br><span class="line">聚合关系是一种特殊的关联关系，聚合关系表示的是类之间整体与部分的关系，用带有空心菱形的实线表示，空心菱形指向代表整体的类。</span><br><span class="line"></span><br><span class="line">5.实现关系</span><br><span class="line">定义接口，用户带空心箭头的虚线来表示</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;类图基本属性&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>python导包时的一些细节问题</title>
    <link href="https://rebiocoder.github.io/2020/03/22/ython%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/"/>
    <id>https://rebiocoder.github.io/2020/03/22/ython%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/</id>
    <published>2020-03-22T02:21:00.000Z</published>
    <updated>2021-01-05T04:10:17.929Z</updated>
    
    <content type="html"><![CDATA[<p>python导包时的问题</p><p>1.可以使用sys.path,查看python导包的搜素路径;使用sys.modules来查看已经导入内存的模块.</p><p>一个细节点: <code>import 模块</code> import只能导入模块(.py, .pyc,pyd),不能导入模块中的类和函数。如果需要导入模块中的函数或者对象，使用<code>from 模块 import 对象</code></p><p>即为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">说一个容易忽略的问题，import只能导入模块，不能导入模块中的对象（类、函数、变量等）。如一个模块A（A.py）中有个函数getName，另一个模块不能通过import A.getName将getName导入到本模块，只能用import A。如果想只导入特定的类、函数、变量则用from A import getName即可。</span><br></pre></td></tr></table></figure><p>2.嵌套导包</p><p>（1）在A.py中导入<code>import B</code>, 在B.py中导入了<code>import C</code>,则在A中只能使用B而不能使用C,即时C已经存在于内存之中。也就是说必须显示导包</p><p>（2）第二种情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[A.py] </span><br><span class="line">from B import C</span><br><span class="line">class D:</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">[B.py]</span><br><span class="line">from A import D</span><br><span class="line">class C:</span><br><span class="line">pass</span><br></pre></td></tr></table></figure><p>在A中执行C()时,将会报错, 而如果改成<code>import B</code>则可以导入,解释如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">另外一种嵌套指，在模块A中import B，而在模块B中import A。这时会怎么样呢？这个在Python列表中由RobertChen给出了详细解释，抄录如下：</span><br><span class="line"></span><br><span class="line">[A.py] from B import D class C:pass [B.py] from A import C class D:pass</span><br><span class="line"></span><br><span class="line">为什么执行A的时候不能加载D呢？</span><br><span class="line"></span><br><span class="line">如果将A.py改为：import B就可以了。</span><br><span class="line"></span><br><span class="line">这是怎么回事呢？</span><br><span class="line"></span><br><span class="line">RobertChen：这跟Python内部import的机制是有关的，具体到from B import D，Python内部会分成几个步骤：</span><br><span class="line"></span><br><span class="line">在sys.modules中查找符号&quot;B&quot;</span><br><span class="line">果符号B存在，则获得符号B对应的module对象。</span><br><span class="line">从的__dict__中获得符号&quot;D&quot;对应的对象，如果&quot;D&quot;不存在，则抛出异常</span><br><span class="line"></span><br><span class="line">如果符号B不存在，则创建一个新的module对象，注意，这时，module对象的__dict__为空。执行B.py中的表达式，填充的__dict__ 。</span><br><span class="line"></span><br><span class="line">从的__dict__中获得&quot;D&quot;对应的对象，如果&quot;D&quot;不存在，则抛出异常。</span><br><span class="line"></span><br><span class="line">所以，这个例子的执行顺序如下：</span><br><span class="line"></span><br><span class="line">1、执行A.py中的from B import D</span><br><span class="line"></span><br><span class="line">由于是执行的python A.py，所以在sys.modules中并没有存在，首先为B.py创建一个module对象()，注意，这时创建的这个module对象是空的，里边啥也没有，在Python内部创建了这个module对象之后，就会解析执行B.py，其目的是填充这个dict。</span><br><span class="line"></span><br><span class="line">2、执行B.py中的from A import C</span><br><span class="line"></span><br><span class="line">在执行B.py的过程中，会碰到这一句，首先检查sys.modules这个module缓存中是否已经存在了，由于这时缓存还没有缓存，所以类似的，Python内部会为A.py创建一个module对象()，然后，同样地，执行A.py中的语句。</span><br><span class="line"></span><br><span class="line">3、再次执行A.py中的from B import D</span><br><span class="line"></span><br><span class="line">这时，由于在第1步时，创建的对象已经缓存在了sys.modules中，所以直接就得到了，但是，注意，从整个过程来看，我们知道，这时还是一个空的对象，里面啥也没有，所以从这个module中获得符号&quot;D&quot;的操作就会抛出异常。如果这里只是import B，由于&quot;B&quot;这个符号在sys.modules中已经存在，所以是不会抛出异常的。</span><br></pre></td></tr></table></figure><p>导入包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Package（包） Import</span><br><span class="line"></span><br><span class="line">包（Package）可以看成模块的集合，只要一个文件夹下面有个__init__.py文件，那么这个文件夹就可以看做是一个包。包下面的文件夹还可以成为包（子包）。更进一步，多个较小的包可以聚合成一个较大的包，通过包这种结构，方便了类的管理和维护，也方便了用户的使用。比如SQLAlchemy等都是以包的形式发布给用户的。</span><br><span class="line"></span><br><span class="line">包和模块其实是很类似的东西，如果查看包的类型import SQLAlchemy type(SQLAlchemy)，可以看到其实也是。import包的时候查找的路径也是sys.path。</span><br><span class="line"></span><br><span class="line">包导入的过程和模块的基本一致，只是导入包的时候会执行此包目录下的__init__.py而不是模块里面的语句了。另外，如果只是单纯的导入包，而包的__init__.py中又没有明确的其他初始化操作，那么此包下面的模块是不会自动导入的。如：</span><br><span class="line"></span><br><span class="line">PA</span><br><span class="line"></span><br><span class="line">--__init__.py</span><br><span class="line"></span><br><span class="line">--wave.py</span><br><span class="line"></span><br><span class="line">--PB1</span><br><span class="line"></span><br><span class="line">??--__init__.py</span><br><span class="line"></span><br><span class="line">??--pb1_m.py</span><br><span class="line"></span><br><span class="line">--PB2</span><br><span class="line"></span><br><span class="line">??--__init__.py</span><br><span class="line"></span><br><span class="line">??--pb2_m.py</span><br><span class="line"></span><br><span class="line">__init__.py都为空，如果有以下程序：</span><br><span class="line"></span><br><span class="line">?</span><br><span class="line"></span><br><span class="line">import?sys</span><br><span class="line">import?PA.wave??#1</span><br><span class="line">import?PA.PB1???#2</span><br><span class="line">import?PA.PB1.pb1_m?as?m1??#3</span><br><span class="line"></span><br><span class="line">import?PA.PB2.pb2_m?#4</span><br><span class="line"></span><br><span class="line">PA.wave.getName()?#5</span><br><span class="line"></span><br><span class="line">m1.getName()?#6</span><br><span class="line"></span><br><span class="line">PA.PB2.pb2_m.getName()?#7</span><br><span class="line">当执行#1后，sys.modules会同时存在PA、PA.wave两个模块，此时可以调用PA.wave的任何类或函数了。但不能调用PA.PB1(2)下的任何模块。当前Local中有了PA名字。</span><br><span class="line"></span><br><span class="line">当执行#2后，只是将PA.PB1载入内存，sys.modules中会有PA、PA.wave、PA.PB1三个模块，但是PA.PB1下的任何模块都没有自动载入内存，此时如果直接执行PA.PB1.pb1_m.getName()则会出错，因为PA.PB1中并没有pb1_m。当前Local中还是只有PA名字，并没有PA.PB1名字。</span><br><span class="line"></span><br><span class="line">当执行#3后，会将PA.PB1下的pb1_m载入内存，sys.modules中会有PA、PA.wave、PA.PB1、PA.PB1.pb1_m四个模块，此时可以执行PA.PB1.pb1_m.getName()了。由于使用了as，当前Local中除了PA名字，另外添加了m1作为 PA.PB1.pb1_m的别名。</span><br><span class="line"></span><br><span class="line">当执行#4后，会将PA.PB2、PA.PB2.pb2_m载入内存，sys.modules中会有PA、PA.wave、PA.PB1、PA.PB1.pb1_m、PA.PB2、PA.PB2.pb2_m六个模块。当前Local中还是只有PA、m1。</span><br><span class="line"></span><br><span class="line">下面的#5，#6，#7都是可以正确运行的。</span><br><span class="line"></span><br><span class="line">注意的是：如果PA.PB2.pb2_m想导入PA.PB1.pb1_m、PA.wave是可以直接成功的。最好是采用明确的导入路径，对于.&#x2F;..相对导入路径还是不推荐用。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;python导包时的问题&lt;/p&gt;
&lt;p&gt;1.可以使用sys.path,查看python导包的搜素路径;使用sys.modules来查看已经导入内存的模块.&lt;/p&gt;
&lt;p&gt;一个细节点: &lt;code&gt;import 模块&lt;/code&gt; import只能导入模块(.py, .pyc</summary>
      
    
    
    
    <category term="python" scheme="https://rebiocoder.github.io/categories/python/"/>
    
    
    <category term="python" scheme="https://rebiocoder.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>[算法设计]动态规划求最长公共子序列</title>
    <link href="https://rebiocoder.github.io/2020/03/05/%E6%B3%95%E8%AE%BE%E8%AE%A1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B1%82%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://rebiocoder.github.io/2020/03/05/%E6%B3%95%E8%AE%BE%E8%AE%A1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B1%82%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2020-03-05T05:01:00.000Z</published>
    <updated>2021-01-05T04:17:24.829Z</updated>
    
    <content type="html"><![CDATA[<p>问题: 已知序列str1和序列str2,求出他们的最长公共子序列。</p><p><code>dp[i][j]</code>的定义: <code>str[0-i]</code>和<code>str[0-j]</code>所拥有的最长公共子序列。</p><p>法一:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def length_common_strength(str1, str2) -&gt; int:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    递归法求解</span><br><span class="line">    :param str1:</span><br><span class="line">    :param str2:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def dp(i, j):</span><br><span class="line">        if i &#x3D;&#x3D; -1 or j &#x3D;&#x3D; -1: return 0</span><br><span class="line">        if str1[i] &#x3D;&#x3D; str2[j]:</span><br><span class="line">            return dp(i-1, j-1) + 1</span><br><span class="line">        else:</span><br><span class="line">            return max(dp(i-1, j), dp(i, j-1))</span><br><span class="line">    return dp(len(str1) - 1, len(str2) - 1)</span><br></pre></td></tr></table></figure><p>法二:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def length_common_strength_dp(str1, str2) -&gt; int:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    dp背包</span><br><span class="line">    :param str1:</span><br><span class="line">    :param str2:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    m, n &#x3D; len(str1), len(str2)</span><br><span class="line">    dp &#x3D; [[0] * (n + 1) for _ in range(m+1)]</span><br><span class="line">    for i in range(1, m+1):</span><br><span class="line">        for j in range(1, n+1):</span><br><span class="line">            if str1[i-1] &#x3D;&#x3D; str2[j-1]:</span><br><span class="line">                dp[i][j] &#x3D; dp[i-1][j-1] + 1</span><br><span class="line">            else:</span><br><span class="line">                dp[i][j] &#x3D; max(dp[i-1][j], dp[i][j-1])</span><br><span class="line">    return dp[m][n]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;问题: 已知序列str1和序列str2,求出他们的最长公共子序列。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i][j]&lt;/code&gt;的定义: &lt;code&gt;str[0-i]&lt;/code&gt;和&lt;code&gt;str[0-j]&lt;/code&gt;所拥有的最长公共子序列。&lt;/p&gt;
&lt;p&gt;法一:&lt;/p&gt;</summary>
      
    
    
    
    <category term="算法设计" scheme="https://rebiocoder.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="算法" scheme="https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[算法设计]求最长子序列问题</title>
    <link href="https://rebiocoder.github.io/2020/03/02/%E6%B3%95%E8%AE%BE%E8%AE%A1-%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <id>https://rebiocoder.github.io/2020/03/02/%E6%B3%95%E8%AE%BE%E8%AE%A1-%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-02T10:00:00.000Z</published>
    <updated>2021-01-05T04:17:07.237Z</updated>
    
    <content type="html"><![CDATA[<p>问题: 求无序序列的最长子序列</p><p>方法: 动态规划法</p><p>关键点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] : 表示数组中的第i位置的最长子序列的长度,初始默认所有位置的dp[i] &#x3D; 1</span><br></pre></td></tr></table></figure><p>思路: 假设已知<code>Subsequence[i-1]</code>位置的最长子序列为<code>dp[i-1]</code>,则<code>dp[i]</code>,显然如果<code>subsequence[i]&gt;subsequence[i-1]</code>,则<code>dp[i] = dp[i-1] + 1</code></p><p>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;*求最长子序列*&#x2F;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">const int MaxN &#x3D; 100;</span><br><span class="line">int Subsequence[MaxN];</span><br><span class="line">int dp[MaxN];</span><br><span class="line">for (int j &#x3D; 0; j &lt; MaxN; ++j) &#123;</span><br><span class="line">dp[j] &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">int n;</span><br><span class="line">scanf_s(&quot;%d&quot;, &amp;n);</span><br><span class="line">if (n !&#x3D; 0) &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">scanf_s(&quot;%d&quot;, &amp;Subsequence[i]); &#x2F;&#x2F;子序</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">for (int j &#x3D; 0; j &lt; i; ++j) &#123;</span><br><span class="line">if (Subsequence[i] &gt; Subsequence[j]) &#123;</span><br><span class="line">dp[i] &#x3D; max(dp[j] + 1, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;                                    </span><br><span class="line">printf(&quot;输入结束!\n&quot;);</span><br><span class="line">for (int j &#x3D; 0; j &lt; n; ++j) &#123;</span><br><span class="line">printf(&quot;%d&quot;, Subsequence[j]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">for (int j &#x3D; 0; j &lt; n; ++j) &#123;</span><br><span class="line">printf(&quot;%d&quot;, dp[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;问题: 求无序序列的最长子序列&lt;/p&gt;
&lt;p&gt;方法: 动态规划法&lt;/p&gt;
&lt;p&gt;关键点:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;</summary>
      
    
    
    
    <category term="算法设计" scheme="https://rebiocoder.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="算法" scheme="https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[算法设计]斐波拉契优化与区间不相交问题</title>
    <link href="https://rebiocoder.github.io/2020/03/02/%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-5/"/>
    <id>https://rebiocoder.github.io/2020/03/02/%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-5/</id>
    <published>2020-03-02T03:11:00.000Z</published>
    <updated>2021-01-05T04:10:18.529Z</updated>
    
    <content type="html"><![CDATA[<p>斐波拉契数,最基本的定义用递归,现利用”自底向上”的思路求解:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line"></span><br><span class="line">int BaseFib(int n) &#123;&#x2F;&#x2F;暴力递归斐波拉契数列</span><br><span class="line">if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) return 1; &#x2F;&#x2F;递归出口</span><br><span class="line">return BaseFib(n - 1) + BaseFib(n - 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int DpTableFib(int n) &#123;&#x2F;&#x2F;dpTable,自底向上</span><br><span class="line">int dp[1000] &#x3D; &#123;0&#125;; &#x2F;&#x2F;初始化为0</span><br><span class="line">dp[1] &#x3D; 1;</span><br><span class="line">dp[2] &#x3D; 1;</span><br><span class="line">for (int i &#x3D; 3; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">dp[i] &#x3D; dp[i - 1] + dp[i - 2];</span><br><span class="line">&#125;</span><br><span class="line">return dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int n &#x3D; 20;</span><br><span class="line">int m &#x3D; n;</span><br><span class="line">printf(&quot;%d&quot;, BaseFib(n));</span><br><span class="line">printf(&quot;%d&quot;, DpTableFib(m));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不相交子区间问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">区间不相交问题</span><br><span class="line">*&#x2F;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MaxN &#x3D; 10;</span><br><span class="line">struct interval</span><br><span class="line">&#123;</span><br><span class="line">int x, y; &#x2F;&#x2F;开区间左右端点</span><br><span class="line">&#125; I[MaxN];</span><br><span class="line"></span><br><span class="line">bool cmp(interval a, interval b) &#123;</span><br><span class="line">if (a.x !&#x3D; b.x) return a.x &gt; b.x; &#x2F;&#x2F;先按照左端点从大到小的顺序排序</span><br><span class="line">return a.y &lt; b.y; &#x2F;&#x2F; 如果左端点相同, 则按照右端点从小到大的顺序排序</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int n;</span><br><span class="line">while (scanf_s(&quot;%d&quot;, &amp;n), n!&#x3D;0)&#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">scanf_s(&quot;%d%d&quot;, &amp;I[i].x, &amp;I[i].y);</span><br><span class="line">&#125;</span><br><span class="line">sort(I, I + n, cmp);</span><br><span class="line">int ans &#x3D; 1, lastX &#x3D; I[0].x;</span><br><span class="line">for (int i &#x3D; 1; i &lt; n; ++i) &#123;</span><br><span class="line">if (I[i].y &lt;&#x3D; lastX) &#123;</span><br><span class="line">lastX &#x3D; I[i].x;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;斐波拉契数,最基本的定义用递归,现利用”自底向上”的思路求解:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;sp</summary>
      
    
    
    
    
    <category term="算法" scheme="https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[算法设计]全排列与n皇后问题</title>
    <link href="https://rebiocoder.github.io/2020/02/28/%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-4/"/>
    <id>https://rebiocoder.github.io/2020/02/28/%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-4/</id>
    <published>2020-02-28T10:37:00.000Z</published>
    <updated>2021-01-05T04:16:48.341Z</updated>
    
    <content type="html"><![CDATA[<p><strong>全排列</strong></p><p><img src="https://i.loli.net/2020/02/28/brp17aE9OHwfouh.png" alt="1582886314_1_.png"></p><p><strong>递归算法求全排</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">递归求全排</span><br><span class="line">*&#x2F;</span><br><span class="line">const int MaxN &#x3D; 10;</span><br><span class="line">const int MAXSIZE &#x3D; 1000;</span><br><span class="line">int P[MaxN];</span><br><span class="line">bool hashTable[MAXSIZE] &#x3D; &#123; false &#125;; &#x2F;&#x2F;空间换取时间</span><br><span class="line">int n;</span><br><span class="line">void generateP(int index) &#123;</span><br><span class="line">if (index &#x3D;&#x3D; n + 1) &#123;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">printf(&quot;%d&quot;, P[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for (int j &#x3D; 1; j &lt;&#x3D; n; ++j) &#123;</span><br><span class="line">if (hashTable[j] &#x3D;&#x3D; false) &#123;</span><br><span class="line">P[index] &#x3D; j;</span><br><span class="line">hashTable[j] &#x3D; true;</span><br><span class="line">generateP(index + 1);</span><br><span class="line">hashTable[j] &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">n &#x3D; 5;</span><br><span class="line">generateP(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>n皇后问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;n皇后问题,回溯法</span><br><span class="line">int count &#x3D; 0;</span><br><span class="line">void queen(int index) &#123;&#x2F;&#x2F;第n列的皇后</span><br><span class="line">if (index &#x3D;&#x3D; n + 1) &#123;&#x2F;&#x2F;此时每一列都有一个皇后</span><br><span class="line">count++;</span><br><span class="line">printf(&quot;%d\n&quot;,count);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">if (hashTable[i] &#x3D;&#x3D; false) &#123;&#x2F;&#x2F;没有被使用过</span><br><span class="line">bool flag &#x3D; true; &#x2F;&#x2F;表示当前序列与之前的皇后不冲突</span><br><span class="line">for (int pre &#x3D; 1; pre &lt;&#x3D; index; ++pre) &#123;&#x2F;&#x2F;回溯剪枝</span><br><span class="line">&#x2F;&#x2F;不能在同一对角线上</span><br><span class="line">if (abs(pre - index) &#x3D;&#x3D; abs(i - P[pre])) &#123;</span><br><span class="line">flag &#x3D; false;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (flag) &#123;</span><br><span class="line">P[index] &#x3D; i;</span><br><span class="line">hashTable[i] &#x3D; true;</span><br><span class="line">queen(index + 1);</span><br><span class="line">hashTable[i] &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">n &#x3D; 8;</span><br><span class="line">queen(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;全排列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/02/28/brp17aE9OHwfouh.png&quot; alt=&quot;1582886314_1_.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;递归算法求全排&lt;</summary>
      
    
    
    
    <category term="算法设计" scheme="https://rebiocoder.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="算法" scheme="https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[算法设计]hash</title>
    <link href="https://rebiocoder.github.io/2020/02/27/%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-3/"/>
    <id>https://rebiocoder.github.io/2020/02/27/%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-3/</id>
    <published>2020-02-27T09:57:00.000Z</published>
    <updated>2021-01-05T04:10:18.429Z</updated>
    
    <content type="html"><![CDATA[<p><strong>hash</strong></p><p>基本问题<br><img src="https://i.loli.net/2020/02/27/AZh6EvzaSJUOTGI.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#define MAXSIZE 1000</span><br><span class="line">void HashInt(int a[], int b[]) &#123;</span><br><span class="line">bool c[MAXSIZE] &#x3D; &#123; false &#125;;</span><br><span class="line">int m, n;</span><br><span class="line">printf(&quot;a,b数组元素的个数:&quot;);</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;m, &amp;n);</span><br><span class="line">for (int i &#x3D; 0; i &lt; m; ++i) &#123;</span><br><span class="line">int tmp;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;tmp);</span><br><span class="line">a[i] &#x3D; tmp;</span><br><span class="line">c[tmp] &#x3D; true;</span><br><span class="line">&#125;&#x2F;&#x2F;空间换取时间</span><br><span class="line">for (int j &#x3D; 0; j &lt; n; ++j) &#123;</span><br><span class="line">int tmp;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;tmp);</span><br><span class="line">b[j] &#x3D; tmp;</span><br><span class="line">if (c[tmp]) printf(&quot;%d在a中存在&quot;,tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串hash</strong></p><p>大写字符hash核心代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0; i&lt;len(s): ++i)&#123;</span><br><span class="line">id &#x3D; id*26 + (s[i]- &#39;A&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大小写字母均hash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0; i&lt;len(s): ++i)&#123;</span><br><span class="line">if(s[i]&gt;&#39;A&#39; &amp;&amp; s[i]&lt;&#39;Z&#39;)</span><br><span class="line">id &#x3D; id*26 + (s[i]- &#39;A&#39;)</span><br><span class="line">else(s[i]&gt;&#39;a&#39; &amp;&amp; s[i]&lt;&#39;z&#39;)</span><br><span class="line">id &#x3D; id*52 + (s[i]-&#39;a&#39;) + 26</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;hash&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本问题&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2020/02/27/AZh6EvzaSJUOTGI.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;hig</summary>
      
    
    
    
    
    <category term="算法" scheme="https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[算法设计]基本排序</title>
    <link href="https://rebiocoder.github.io/2020/02/27/%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-2/"/>
    <id>https://rebiocoder.github.io/2020/02/27/%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-2/</id>
    <published>2020-02-27T09:02:00.000Z</published>
    <updated>2021-01-05T04:17:51.369Z</updated>
    
    <content type="html"><![CDATA[<h6 id="基本排序算法"><a href="#基本排序算法" class="headerlink" title="基本排序算法"></a>基本排序算法</h6><p><strong>bubbleSort</strong></p><p><strong>关键点</strong>:一轮能够确定一个数,内层循环有:<code>a[j]&gt;a[j+1]</code>,保证<code>a[j+1]</code>不溢出,第一轮循环需要从<code>i=1</code>开始,内层循环从<code>j=0</code>开始,<code>j&lt;n-i</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void BubbleSort(int a[], int n) &#123;&#x2F;&#x2F;冒泡排序,a为数据数组, n为数组元素个数</span><br><span class="line">int tmp;</span><br><span class="line">for (int i &#x3D; 1; i &lt; n; ++i) &#123;</span><br><span class="line">for (int j &#x3D; 0; j &lt; n - i; ++j) &#123;</span><br><span class="line">if (a[j] &gt; a[j + 1]) &#123;&#x2F;&#x2F;前一个元素大于后一个元素</span><br><span class="line">tmp &#x3D; a[j];</span><br><span class="line">a[j] &#x3D; a[j + 1];</span><br><span class="line">a[j + 1] &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>selectSort</strong></p><p><strong>关键点</strong>:与bubble刚好相反,它是从前往后排,所以关键在内层循环的<code>int j=i</code>开始点,而冒泡则是内层循环的<code>j&lt;n-i</code>结束的点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void selectSort(int a[], int n) &#123;&#x2F;&#x2F;选择排序</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">int m &#x3D; i;</span><br><span class="line">for (int j &#x3D; i; j &lt; n; ++j ) &#123;</span><br><span class="line">if (a[m] &gt; a[j]) &#123;</span><br><span class="line">m &#x3D; j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int tmp &#x3D; a[i];</span><br><span class="line">a[i] &#x3D; a[m];</span><br><span class="line">a[m] &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;基本排序算法&quot;&gt;&lt;a href=&quot;#基本排序算法&quot; class=&quot;headerlink&quot; title=&quot;基本排序算法&quot;&gt;&lt;/a&gt;基本排序算法&lt;/h6&gt;&lt;p&gt;&lt;strong&gt;bubbleSort&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键点&lt;/strong</summary>
      
    
    
    
    <category term="算法设计" scheme="https://rebiocoder.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="算法" scheme="https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[算法设计]求幂集</title>
    <link href="https://rebiocoder.github.io/2020/02/25/%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>https://rebiocoder.github.io/2020/02/25/%E6%B3%95%E5%88%86%E6%9E%90/</id>
    <published>2020-02-25T10:12:00.000Z</published>
    <updated>2021-01-05T04:18:03.253Z</updated>
    
    <content type="html"><![CDATA[<h6 id="算法设计与分析-1"><a href="#算法设计与分析-1" class="headerlink" title="算法设计与分析(1)"></a>算法设计与分析(1)</h6><p><strong>求幂集问题(穷举法)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个数n,求出从1-n的所有子集</span><br></pre></td></tr></table></figure><p>法一:直接穷举</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define MaxN 100 &#x2F;&#x2F;元素的最大值</span><br><span class="line">#define MaxSize 100 &#x2F;&#x2F;子集的最大值</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">int n; &#x2F;&#x2F;子集我的个数</span><br><span class="line">int data[MaxSize][MaxN]; &#x2F;&#x2F;元素</span><br><span class="line">&#125;PsetType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void copy(int a[], int b[], int n)&#123;&#x2F;&#x2F;将a数组的值复制给b数组</span><br><span class="line">for(int i&#x3D;0; i&lt;&#x3D;n; ++i)</span><br><span class="line">b[i] &#x3D; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pset(int n, PsetType &amp;p)&#123;</span><br><span class="line">int a[MaxN];</span><br><span class="line">&#x2F;&#x2F;初始化</span><br><span class="line">p.data[0][0] &#x3D; 0;</span><br><span class="line">p.n &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F;初始化结束</span><br><span class="line">for(int i&#x3D;1; i&lt;&#x3D;n; ++i)&#123;</span><br><span class="line">int m &#x3D; p.n; &#x2F;&#x2F;原幂集中子集的个数</span><br><span class="line">for(int j&#x3D;0; j&lt;m; ++j)&#123;</span><br><span class="line">copy(p.data[j], a, p.data[j][0]);</span><br><span class="line">a[0]++; &#x2F;&#x2F;子集元素个数加1</span><br><span class="line">a[a[0]] &#x3D; i;</span><br><span class="line">copy(a, p.data[p.n], a[0]);</span><br><span class="line">p.n++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void disp(PsetType p)&#123;</span><br><span class="line">for(int i&#x3D;0; i&lt;p.n; ++i)&#123;</span><br><span class="line">printf(&quot;&#123;&quot;);</span><br><span class="line">for(int j&#x3D;1; j&lt;&#x3D;p.data[i][0];++j)&#123;</span><br><span class="line">printf(&quot;%d&quot;,p.data[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;&#125;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">PsetType p;</span><br><span class="line">int n &#x3D; 5;</span><br><span class="line">pset(n, p);</span><br><span class="line">disp(p);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>法二:增量穷举法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define MaxN 100 &#x2F;&#x2F;元素的最大值</span><br><span class="line">#define MaxSize 100 &#x2F;&#x2F;子集的最大值</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">int n; &#x2F;&#x2F;子集我的个数</span><br><span class="line">int data[MaxSize][MaxN]; &#x2F;&#x2F;元素</span><br><span class="line">&#125;PsetType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void copy(int a[], int b[], int n)&#123;&#x2F;&#x2F;将a数组的值复制给b数组</span><br><span class="line">for(int i&#x3D;0; i&lt;&#x3D;n; ++i)</span><br><span class="line">b[i] &#x3D; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pset(int n, PsetType &amp;p)&#123;</span><br><span class="line">int a[MaxN];</span><br><span class="line">&#x2F;&#x2F;初始化</span><br><span class="line">p.data[0][0] &#x3D; 0;</span><br><span class="line">p.n &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F;初始化结束</span><br><span class="line">for(int i&#x3D;1; i&lt;&#x3D;n; ++i)&#123;</span><br><span class="line">int m &#x3D; p.n; &#x2F;&#x2F;原幂集中子集的个数</span><br><span class="line">for(int j&#x3D;0; j&lt;m; ++j)&#123;</span><br><span class="line">copy(p.data[j], a, p.data[j][0]);</span><br><span class="line">a[0]++; &#x2F;&#x2F;子集元素个数加1</span><br><span class="line">a[a[0]] &#x3D; i;</span><br><span class="line">copy(a, p.data[p.n], a[0]);</span><br><span class="line">p.n++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void disp(PsetType p)&#123;</span><br><span class="line">for(int i&#x3D;0; i&lt;p.n; ++i)&#123;</span><br><span class="line">printf(&quot;&#123;&quot;);</span><br><span class="line">for(int j&#x3D;1; j&lt;&#x3D;p.data[i][0];++j)&#123;</span><br><span class="line">printf(&quot;%d&quot;,p.data[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;&#125;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">PsetType p;</span><br><span class="line">int n &#x3D; 5;</span><br><span class="line">pset(n, p);</span><br><span class="line">disp(p);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例图:<br><img src="https://i.loli.net/2020/02/25/hwO6yI3VmGeJKjS.png" alt="1582625906_1_.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;算法设计与分析-1&quot;&gt;&lt;a href=&quot;#算法设计与分析-1&quot; class=&quot;headerlink&quot; title=&quot;算法设计与分析(1)&quot;&gt;&lt;/a&gt;算法设计与分析(1)&lt;/h6&gt;&lt;p&gt;&lt;strong&gt;求幂集问题(穷举法)&lt;/strong&gt;&lt;/p&gt;
&lt;figure </summary>
      
    
    
    
    <category term="算法设计" scheme="https://rebiocoder.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="算法" scheme="https://rebiocoder.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>离散结构笔记(1)</title>
    <link href="https://rebiocoder.github.io/2020/02/21/%E6%95%A3%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://rebiocoder.github.io/2020/02/21/%E6%95%A3%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-1/</id>
    <published>2020-02-21T05:37:39.000Z</published>
    <updated>2021-01-05T04:10:18.229Z</updated>
    
    <content type="html"><![CDATA[<p>命题: 能判断真假的陈述句称为命题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 感叹句,祈使句,疑问句都不是命题</span><br><span class="line">2. 悖论不是命题</span><br><span class="line">3.判断结果不能唯一确定的不是命题</span><br></pre></td></tr></table></figure><p>简单命题: 由一个简单陈述句组成(原子命题,不能再分)</p><p>复合命题: 简单命题 + 联结词</p><p>五种常用的联结词:否定,合取,析取,蕴涵,等价</p><p>否定: 非,并非</p><hr><p>合取</p><p>合取词: “且”</p><p><code>P 且 Q</code></p><p>当且仅当P和Q同时为真</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P并且Q</span><br><span class="line">不但P而且Q</span><br><span class="line">既P又Q</span><br><span class="line">尽管P还Q</span><br><span class="line">虽然P但是Q</span><br></pre></td></tr></table></figure><hr><p>析取</p><p>析取词: 或</p><p>P或Q: 为假,当且仅当P和Q同时为假</p><p>分类: 相容或,排斥或</p><hr><p>蕴涵词<br>如果..  那么 ..</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;命题: 能判断真假的陈述句称为命题&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>tornado与vue.js解决web一对一实时聊天（IM）</title>
    <link href="https://rebiocoder.github.io/2020/02/17/ornado%E4%B8%8Evue-js%E5%AE%9E%E7%8E%B0web%E4%B8%80%E5%AF%B9%E4%B8%80%E8%81%8A%E5%A4%A9/"/>
    <id>https://rebiocoder.github.io/2020/02/17/ornado%E4%B8%8Evue-js%E5%AE%9E%E7%8E%B0web%E4%B8%80%E5%AF%B9%E4%B8%80%E8%81%8A%E5%A4%A9/</id>
    <published>2020-02-17T13:56:00.000Z</published>
    <updated>2021-01-05T04:10:17.829Z</updated>
    
    <content type="html"><![CDATA[<p>整个小项目最核心的通讯功能能够实现，效果如图：<br><img src="https://i.loli.net/2020/02/17/2OIB14f9rlW67Xm.png" alt="demo图片"></p><p>记录一下这个阶段遇到的一些问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解决方案：</span><br><span class="line">前端vue.js+ajax</span><br><span class="line">后端django rest framework + tornado</span><br><span class="line">用户鉴权用JWT</span><br><span class="line">redis做系统缓存</span><br></pre></td></tr></table></figure><p>一.前后端鉴权问题</p><p>1.django api鉴权</p><p>django通过鉴定http请求头的Authorization头部，进行鉴权。<br><img src="https://i.loli.net/2020/02/17/37ZXfFqpPexV9O8.png" alt="AZ9Y5E6OHP_HC_O0ZYNF_HS.png"></p><p>当收到请求时，主要是以下方面的问题：</p><ul><li>该token是否真实有效</li><li>该token所代表的用户是否为唯一登录</li><li>该token还有多久将会失效，若即将失效，则刷新token，同时要防止并发时，多次重复刷新</li></ul><p><strong>解决思路</strong></p><p>对token发放的后端接口进行拦截，将<code>/new_token</code>得到的新token存入redis中，将/refresh_token得到的刷新token也存入redis中。 当得到一个带有Authorizaion请求头的请求时，首先通过decode该token，得到username和user_id（注意这里无论token是否失效都可以解码出来基本信息）,然后在redis中查询only_key，这里实际上就解决了1，2两个问题。 刷新token的问题，没有找到特别好的解决方案，采用的是，在redis中存储一个refresh_token，如果已经刷新，则不再刷新（防止重复刷新）。</p><p>2 . tornado api鉴权</p><p>tornado中没有django中中间件的概念，通过python的修饰器来进行鉴权，与django鉴权相同。</p><p>3.vue.js鉴权</p><p>采用<code>router.beforeEach</code>进行全局验证，需要验证的页面在<code>meta</code>中添加<code>requiresAuth</code>字段。</p><p>4.axios鉴权</p><p>新建一个<code>api.js</code>，<code>create</code>一个axios实例，在axios的拦截器中添加请求头<code>Authorization</code>。   所以api请求同一存放在api.js中，在组件中使用时，调用相关promise函数。由于axios是异步的，所以在long pool时，容易出现超时中断的情况。这里我不得不在vue中引入了jquery，用ajax做长轮询。（有好的解决方案也可以交流）</p><p>5.由于浏览器的限制，ajax请求容易出现cors，跨域请求失败。 在django中可以直接安装第三方组件来解决，在tornado中不行。 当请求方式为get和部分post时是不会出现cors错误的，但是当post，dataType为json时，这时为非简单请求中的一种，浏览器会自动发送一个options进行嗅探，查看server是否支持该ip的请求，在tornado中设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.set_header(&#39;Access-Control-Allow-Origin&#39;, &#39;http:&#x2F;&#x2F;172.20.10.3:8080&#39;)</span><br><span class="line">self.set_header(&#39;Access-Control-Allow-Credentials&#39;, True)</span><br><span class="line">self.set_header(&#39;Access-Control-Allow-Headers&#39;,</span><br><span class="line">                &#39;Origin, X-Requested-With, Content-Type, Accept, Authorization, athorization&#39;)</span><br><span class="line">self.set_header(&#39;Access-Control-Allow-Methods&#39;, &#39;POST, GET, PUT, DELETE&#39;)</span><br></pre></td></tr></table></figure><p><code>Access-Control-Allow-Origin</code>中为前端ip+端口号，表示同意该ip的非简单请求。</p><p>二. tornado处理实时聊天消息</p><p>处理实时的信息，django自己的一套并不好用，<code>django-channels</code>加websocket虽然能实现简单的实时通信，但是效果并不好。tornado是一个异步web框架，处理实时消息，作为django的一个组件（这里说的并不准确，因为tornado的服务器是生产级服务器，可以直接生产部署，再加nginx反向代理，性能十分优越）。参考tornado中ajax聊天室demo（facebook工程师的demo，很值得读，编码规范也可以学习），使用redis做缓存在处理单对单的消息收发。</p><p>三。django与tornado的结合部署</p><p>官网文档有相关的例子，wsgi的结合部署，使用的是tornado的服务器。主要代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wsgi_app &#x3D; wsgi.WSGIContainer(</span><br><span class="line">    django.core.handlers.wsgi.WSGIHandler())</span><br><span class="line">tornado_app &#x3D; tornado.web.Application(</span><br><span class="line">    [</span><br><span class="line">        (&#39;&#x2F;api&#x2F;v1&#x2F;all-message&#x2F;&#39;, ChatCacheApi.IndexMessageHandler),</span><br><span class="line">        (&#39;&#x2F;api&#x2F;v1&#x2F;new-message&#x2F;&#39;, ChatCacheApi.NewMessageHandler),</span><br><span class="line">        (&#39;&#x2F;api&#x2F;v1&#x2F;update-message&#x2F;&#39;, ChatCacheApi.UpdateMessageHandler),</span><br><span class="line">        (&#39;.*&#39;, tornado.web.FallbackHandler, dict(fallback&#x3D;wsgi_app)),</span><br><span class="line">    ])</span><br><span class="line">server &#x3D; tornado.httpserver.HTTPServer(tornado_app)</span><br><span class="line">server.listen(options.options.port, &#39;0.0.0.0&#39;)</span><br><span class="line">tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/17/p96VXecZfD25FwJ.png" alt="13_6AV_3_X1H_M5F82D2_P5.png"></p><p>响应时，将会使用tornado server。</p><hr><p>主要时记录一下思路，具有实现有点麻烦，有需要再记录。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;整个小项目最核心的通讯功能能够实现，效果如图：&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2020/02/17/2OIB14f9rlW67Xm.png&quot; alt=&quot;demo图片&quot;&gt;&lt;/p&gt;
&lt;p&gt;记录一下这个阶段遇到的一些问题。&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    <category term="python" scheme="https://rebiocoder.github.io/categories/python/"/>
    
    
    <category term="tornado" scheme="https://rebiocoder.github.io/tags/tornado/"/>
    
  </entry>
  
</feed>
